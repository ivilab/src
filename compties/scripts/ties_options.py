#!/usr/bin/env python2.7

# $Id: ties_options.py 20821 2016-08-30 00:01:30Z jguan1 $
# Language: python 2.7 (argparse is not in 2.6)
#!/usr/local2/predoehl/VIRTUAL/bin/python is the proper shebang on acan
#!/usr/bin/env python2.7 is the proper shebang on most other systems.
# although on TACC you must load the python module first.
#
# This module parses the arguments.  It supports two related kinds of
# argument use cases:
# 1) One PID, all folds (original-style):  "cross_validate"
#    A single program performs the cross-validated modeling on all
#    folds, sequentially.  This takes more time, less computing power.
# 2) One PID, one fold:  "run_fold"
#    A single program performs modeling on just one fold.  You might want
#    to launch this script several times, each on a different fold, so as to
#    perform the modeling in parallel.  This will take less time but more
#    computing power.
#
# This module also imperfectly supports a third use case:
# 3) Generating plots for existing inference results:
# 3a)  Generating plots for all baseline models and the full TIES model.
# 3b)  Generating plots for the full TIES model, but no baselines.
#
# This third use case occurs when the ties_plots.py script is run as a
# top-level script rather than as a module.  For this third use case, the
# caller is required to provide some "--flag VALUE" argument pairs even
# though the supplied VALUE is going to be ignored after it is validated.
# For example, the user might have to provide a path to a binary baseline
# engine, and it must be an executable file, though it won't be executed.
# This is clearly an illogical and imperfect user interface, but because of
# laziness and the fact that I am the only user of the plotting script, I
# would rather leave it be.  See ties_plots.py for more discussion.
#
# A detailed list of the options is most easily seen by reading the source
# for function _build_my_parser().
#
# Use case 1 requires you to OMIT the option "--single-fold."  Possibly you
# will need options --binary-baseline-engine and --binary-ties-engine which
# let you specify the path to the proper C++ executables (but those options
# have default values that might be adequate).
#
# Use case 2 requires you to provide the arguments "--single-fold k" where k is
# the one-based index of the data to model.  The directory structure is
# expected to conform to that generated by C++ executables parse_real_data
# and create_folds.  Possibly you will need option --binary-run-fold to specify
# the path to the C++ executable, if the default is inadequate.
#
# The default values for the paths to the binary executable works like so.  The
# directory containing the binary defaults to the same directory as the one
# containing this module.  To see the default basename for the binaries, search
# this script for invocations of the toolpath() function.
#
# These names sometimes differ from the names chosen by Jinyan for a
# historical reason (trying to increase clarity in the Discovery Environment)
# that in retrospect was a bad decision.  A key to the changes:
#
# Name produced by build script  Name chosen for DE
# -------------------------------------------------------
# run_base_models                ties_run_baseline_models
# cross_validate                 ties_cross_validation


# Modules from python's standard library:
import argparse
import os, os.path
import sys
import tempfile

# Custom modules:
import ties_log


def _build_my_parser():
    '''
    This builds a parser of command-line arguments for this script.
    Options used in ArgumentParser object are mostly the same as those used by
    Guan's code, for human readability and simplicity.

    This parser accepts a union of the set of options appropriate for python
    scripts "ties_basic_complete_run.py" and "ties_singlefold_run.py,"
    and those sets differ.  So for maximum robustness, the module-user should
    verify that the end-user doesn't include inappropriate options,
    e.g., it would be wrong to use --data-csv-fname for a single-fold run.
    '''
    parser = argparse.ArgumentParser(description='Fit TIES model to one '
        'observable field in data, optionally using one moderator factor, '
        'plus baseline models for comparison.  The TIES model is a coupled '
        'oscillator using parameters shared across dyads.  '
        'Model performance is assessed using cross-validation '
        'and separate fitting and prediction phases.')
    #parser.add_argument('--data-csv-fname',
        #help='Filename of CSV grid of input data.  '
        #'Required, unless running a single fold.')
    parser.add_argument('--data-dir',
        help='Path to directory of pre-parsed input data.  '
        'Required only when running a single fold.')
    parser.add_argument('--distinguisher', required=True,
        help='Name of 0-1 data field (i.e., name of a named CSV column) to '
        'differentiate the two members of the dyad')
    #parser.add_argument('--moderator',
        #help='Name of a data field (i.e., name of a named CSV column) of '
        #'dyadic data that is hypothesized to affect oscillator parameters, '
        #'does not vary in time and belongs to a continuous domain of '
        #'possible value (i.e., NOT categorical).  It is optional.')
    parser.add_argument('--categorical-mod',
        help='Name of a data field (i.e., name of a named CSV column) of '
        'dyadic data that is hypothesized to affect oscillator parameters, '
        'does not vary in time, and represents membership in discrete '
        'categorial class (i.e., NOT continuously-varying).  It is optional.')
    #parser.add_argument('--observable', required=True,
        #help='Name of a data field (CSV column) of observed, individual, time'
        #'-varying data that are hypothetically explainable by the TIES model')
    #parser.add_argument('--output-dir-baselines', default='baselines',
        #help='Name of directory into which to write outputs and results of '
        #'baseline models')
    parser.add_argument('--output-dir-model', default='results', help='Name '
        'of directory into which to write TIES model output and results')
    parser.add_argument('--output-dir-plots', default='plots', help='Name '
        'of directory into which to store plotted results of TIES model')
    parser.add_argument('--model-name', default='model_name', help='Name '
        'model name')
    #parser.add_argument('--config-baseline',
        #help='Optional path of file containing program options in opt=val for'
        #'mat, passed via -C option to inference engine for baseline models.')
    #parser.add_argument('--config-ties',
        #help='Optional path of file containing program options in opt=val '
        #'format, passed via -C option to inference engine for TIES model.')
    #parser.add_argument('--skip-baseline-models', action='store_true',
        #help='If present, directs this script not to compute any baseline '
        #'models')
    #parser.add_argument('--skip-shared-param-baseline', action='store_true',
        #help='If present, directs this script not to compute the shared '
        #'parameter osc. baseline model (i.e., TIES without moderators)')
    #parser.add_argument('--plot-individual-fit', action='store_true',
        #help='Flag:  if present, generate time-domain plots showing each '
        #"dyad's observable data with the model state, over time.")
    parser.add_argument('--single-fold',
        help='If present, this takes the index number of the fold to model, '
        "and it directs the script to model ONLY that fold's data, using the "
        'executable program specified by option --binary-run-fold or its '
        "default.  If absent, the script will model ALL the folds' data, "
        'using the executables specified by options --binary-baseline-engine '
        'and --binary-ties-engine (or their defaults).  '
        'Fold index is one-based.')
    #parser.add_argument('--id-list',
        #help='Filename of list of dyad indices for training data.  '
        #'Required only for single-fold runs; ignored for multi-fold runs.')

    toolpath = lambda s: os.path.join(os.path.dirname(sys.argv[0]), s)

#   options for running one process for all folds (possibly with many threads)
#    bbe_def = toolpath('ties_run_baseline_models')
#    parser.add_argument('--binary-baseline-engine', default=bbe_def,
#        help='Specify the path and filename of the binary of the '
#        'inference engine for baseline models.  '
#        '(Value is ignored if --single-fold is specified.)  '
#        'Default: ' + bbe_def)
#    tcv_def = toolpath('ties_cross_validation')
#    parser.add_argument('--binary-ties-engine', default=tcv_def,
#        help='Specify the path and filename of the binary of the inference '
#        'engine for the cross-validating TIES model.  '
#        '(Value is ignored if --single-fold is specified.)  '
#        'Default: ' + tcv_def)

#   options for running one process per fold (possibly with many threads)
#    ruf_def = toolpath('run_fold')
#    parser.add_argument('--binary-run-fold', default=ruf_def,
#        help='Specify the path and filename of the binary of the inference '
#        'engine for one "fold" of the TIES model.  '
#        '(Value is ignored if --single-fold is left unspecified.)  '
#        'Default: ' + ruf_def)

    return parser


def _indented_list(ls):
    return '\t' + '\n\t'.join(ls) + '\n'


def _debug_echo_args(args):
    'Stringify the values of the command-line options, in args, for debug.'
    dbecho = [
        #'CSV                          = ' + repr(args.data_csv_fname),
        'Data dir                     = ' + repr(args.data_dir),
        #'ID list                      = ' + repr(args.id_list),
        'Distinguisher                = ' + args.distinguisher,
        #'Observable                   = ' + args.observable,
        #'Output dir of baselines      = ' + args.output_dir_baselines,
        'Output dir of model          = ' + args.output_dir_model,
        'Output dir of plots          = ' + args.output_dir_plots,
        #'Plot individual fit          = ' + str(args.plot_individual_fit),
        #'Binary for baselines         = ' + args.binary_baseline_engine,
        #'Binary for TIES x-validation = ' + args.binary_ties_engine,
        #'Binary for TIES single-fold  = ' + args.binary_run_fold,
        #'Continous moderator          = ' + repr(args.moderator),
        'Categorical moderator        = ' + repr(args.categorical_mod),
        'Model name                    = ' + repr(args.model_name),
        #'Config file for baselines    = ' + repr(args.config_baseline),
        #'Config file for TIES model   = ' + repr(args.config_ties),
        #'Skip all baseline models?    = ' + str(args.skip_baseline_models),
        #'Skip shared param. baseline? = ' + str(args.skip_shared_param_baseline),
        'Just a single fold? (None=no): ' + str(args.single_fold),
        repr(args)]

    return _indented_list(dbecho)


def _if_silly_args_then_warn(args):
    '''
    If the command line arguments are flawed or dumb, but not catastrophic,
    issue warnings.
    '''
    warnmsg = []
    #skip_ties = args.moderator is None and args.categorical_mod is None
    warn_no_ties = ('User omitted both a moderator and a categorical moderator.  '
        'That means we are not computing the moderated TIES model.')
    #if args.skip_baseline_models and skip_ties:
        #warnmsg.append('NOTHING TO DO.  ' + warn_no_ties + '  User also chose'
        #' to skip baseline models.  Therefore we are skipping everything.')
    #if args.skip_baseline_models and args.config_baseline is not None:
    #    warnmsg.append('IRRELEVANT BASELINE CONFIG FILE.  '
    #    'User is skipping baseline models, yet provided a config file for '
    #    'baseline models.  It will be ignored.')
    #if skip_ties and args.config_ties is not None:
        #warnmsg.append('IRRELEVANT TIES CONFIG FILE.  ' + warn_no_ties + '  Yet '
        #'the user provided a config file for TIES.  It will be ignored.')

    #if args.single_fold is None:
        #if args.binary_run_fold is not None:
            #warnmsg.append('Irrelevant run_fold exe provided for multi-fold run.')
        #if args.data_dir is not None:
            #warnmsg.append('Irrelevant data dir provided for multi-fold run.')
        #if args.id_list is not None:
        #    warnmsg.append('Irrelevant list filename provided for multi-fold run.')
    #else:
        #if args.data_csv_fname is not None:
            #warnmsg.append('Irrelevant CSV filename provided for single-fold run.')
        #if args.binary_baseline_engine is not None:
        #    warnmsg.append('Irrelevant baseline exe provided for single-fold run.')
        #if args.binary_ties_engine is not None:
        #    warnmsg.append('Irrelevant x-val exe provided for single-fold run.')

    if len(warnmsg) > 0:
        ties_log.log_warning(_indented_list(warnmsg))


def parse_my_args():
    '''
    Parse the command-line arguments to this script; echo them to debug log.
    Sanity-check some of the semantics of the arguments.
    '''
    args = _build_my_parser().parse_args()
    ties_log.log_debug('\n' + _debug_echo_args(args))
    _if_silly_args_then_warn(args)

    #if args.config_baseline is not None:
    #    if not os.path.isfile(args.config_baseline):
    #        raise Exception('config-baseline arg is not a regular file.')

    #if args.config_ties is not None:
        #if not os.path.isfile(args.config_ties):
            #raise Exception('config-ties argument is not a regular file.')

    arg_is_dir = lambda a: a is not None and os.path.isdir(a)
    arg_is_file = lambda a: a is not None and os.path.isfile(a)
    arg_is_mode_x = lambda a: a is not None and os.access(a, os.X_OK)

    #if args.single_fold is None:
        #if not arg_is_file(args.data_csv_fname):
            #raise Exception('Input CSV filename missing or bad')
        #if not args.skip_baseline_models:
            #if not arg_is_mode_x(args.binary_baseline_engine):
                #raise Exception('Baseline binary ought to be executable')
        #skip_ties = args.moderator is None and args.categorical_mod is None
        #if not skip_ties and not arg_is_mode_x(args.binary_ties_engine):
        #    raise Exception('TIES cross_validate binary is not executable')
    #else:
        #if not arg_is_mode_x(args.binary_run_fold):
            #raise Exception('TIES run_fold binary is not executable')
        #if not arg_is_dir(args.data_dir):
            #raise Exception('TIES data directory missing or bad')
        #if not arg_is_file(args.id_list):
            #raise Exception('TIES id-list filename is missing or bad')
        #if int(args.single_fold) < 1:
            #raise Exception('TIES fold number must be a positive integer')

    return args


def _get_alternative_file(bn):
    'Generate a temporary file named similar to the input base filename.'
    j = bn.rfind('.')
    pfx, sfx = (bn + '.', '') if -1 == j else (bn[:j] + '.', bn[j:])
    return tempfile.NamedTemporaryFile(mode='w', suffix=sfx, prefix=pfx,
                                       dir='.', delete=False)


#def fix_bad_eol(args):
#    '''
#    If the input file has old-fashioned end-of-line markers (EOL) that are
#    just carriage returns (like Apple OS-9 did) we translate to Unix format,
#    and save in a new filename.
#    We update args to reflect the new filename in that case, too.
#    If further doctoring of the input were necessary, one could do it here too.
#
#    If you wanted to translate Windows-style EOL too, you could remove the test
#    for zero newlines, and change s.replace('\r', '\n') to the following:
#    s.replace('\r\n', '\n').replace('\r', '\n').
#    However, Windows-style EOL works fine with TIES, so we don't bother.
#    '''
#    with open(args.data_csv_fname, 'r') as f:
#        s = f.read()
#    if '\r' in s and '\n' not in s:
#        with _get_alternative_file(os.path.basename(args.data_csv_fname)) as g:
#            g.write(s.replace('\r', '\n'))
#            args.data_csv_fname = g.name
#        ties_log.log_debug('Input has some carriage returns but no newlines.  '
#            'We assume this is antique Apple OS-9 end of line format, and '
#            'translate to Unix format, replacing each carriage return with a '
#            'newline.  Translated file contents written to "'
#            + args.data_csv_fname + '"')



if __name__ == '__main__':
    p = _build_my_parser()
    print repr(p)
    a = p.parse_args('-h')

