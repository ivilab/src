#!/usr/bin/env python2.7

# $Id: ties_ideal_mod.py 20587 2016-03-26 09:29:07Z predoehl $
#!/usr/bin/env python2.7 is the proper shebang on TACC,
# although on TACC you must load the python module first.
#
# This module does the plots of the full CompTIES model of a shared-parameter
# coupled oscillator, showing its idealized behavior predicted for various
# moderator values.  Usually these values are the 25th percentile and
# 75th percentile of the range of the input data.  In the case of dyads,
# that means showing various combinations.
#
# Incidentally, many combinations are possible.  Moderator values may be
# defined for the dyad or for the individual.  Here are some examples, using
# the abbreviations of 25th percentile as 25p, and 75th percentile as 75p.
# One dyadic moderator:  two plots: (25p) and (75p).
# One individual moderator:  four plots, for partner (0,1) for moderators at
#                            (25p,25p), (25p,75p) (75p,25p) (75p,75p).
# Two dyadic moderators:  four plots
# Two individual moderators: eight plots.  And so on.
#
# Output plots are saved in two formats:  PNG images, and encapsulated
# postscript.  Output filenames are built from lss_set_fitting indices.
# Typical example names:
#    idealized_interaction_00.eps
#    idealized_interaction_00.png
#    idealized_interaction_01.eps
#    idealized_interaction_01.png
#
# Plots are created using Matplotlib.   See ties_plots.py for comments on
# the techniques.
#
# Invoke with these options:
#   --log-dirname logs                where the log file goes (default "logs")
#   --log-basename whatever           (default "ties_ideal_mod.log")
#   --output-dir-plots                where the plots should go (must exist)
#   --charmod-dirname path/to/cm      where the characteristic_models dir is

import argparse
import glob
import matplotlib.figure, matplotlib.backends.backend_agg
import numpy, numpy.ma
import os, os.path

# Custom modules:
import ties_log



def _build_im_parser():
    'This builds a parser of command-line arguments for this script.'
    parser = argparse.ArgumentParser(description='Plot CompTIES predictions '
        'of idealized behavior (i.e., coupled oscillation) '
        'for preset moderator values.')
    parser.add_argument('--output-dir-plots',
        default=os.path.join('plots', 'ideal_behavior'),
        help='Name of directory into which to store plots of idealized '
             'oscillator behavior based on moderator levels.  Please '
             'create this directory prior to calling this script.')
    parser.add_argument('--charmod-dirname', help='Path to directory '
        'generated by lss_set_fitting.  Contents are expected to be '
        'structured in a particular way not spelled out here.')
    return parser


def _plot_with_legend(title, data, curvenames):
    '''
    Generate and return a figure, on which we draw the basic plot and legend.
    This function controls how much to pull back the axes to make room for the
    legend.  If you want a smaller legend, go to work here.
    The add_axes method used normalized coords in domain {x,y : 0 <= x,y <= 1}.
    The four parameters indicate the axes x-position, y-pos, width, height.

    We want the y axis be the same for all plots, so that the amplitudes
    can be compared plot-to-plot.  Thus we create a dummy plot
    (using dummyfig and dummyax) that plots the global min and max values on
    axes we will not render, but we will read their y axis limits, and
    then use those limits on the axes that we really plan to render.
    Those global max and min are stuffed into the last element of data, which
    is expected to be [at least] one element longer than curvenames.
    '''
    dummyfig = matplotlib.figure.Figure()
    dummyax = dummyfig.add_axes([0.1, 0.1, 0.6, 0.75])
    dummyax.plot(data[-1])
    #print data[-1]
    #print dummyax.get_ylim()

    fig = matplotlib.figure.Figure()
    ax = fig.add_axes([0.1, 0.1, 0.6, 0.75])
    ax.set_title(title)
    ax.set_xlabel('time')
    ax.set_ylabel('Observable response')
    ax.set_ylim(dummyax.get_ylim())
    artists = []
    labels = []
    for i,n in enumerate(curvenames):
        assert n[-2] == '-'
        assert n[-1] == '0' or n[-1] == '1'
        l = 'Person ' + n[-1] + ' ' + n[:-2]
        labels.append(l)
        h, = ax.plot(data[i])
        artists.append(h)
    fig.legend(artists, labels, loc='center right')
    return fig


class IdealizedDyad:

    def __init__(self, mods, obsnames, obsvals, outdir, index):
        '''
        mods must be an iterable of tuples of the form (m,p,v) where
        m is the name of the moderator, p is the rank fraction in range 0-1,
        i.e., like percentile * 0.01.  Last, v is the moderator value.

        obsnames is an array of observable names (including distinguisher suffix).

        obsvals has strings of the observable values, and array of arrays
        so each row is a timestep.  Here we  convert them to
        numpy arrays, and do a transpose, so each row is an observable.
        '''
        self._mods = mods
        self._obsnames = obsnames
        self._outdir = outdir
        self._index = index

        o = []
        for i,x in enumerate(obsnames):
            o.append(numpy.array([float(z[i]) for z in obsvals]))
        self._obsvals = o

    def obs_max(self):
        return max(max(z) for z in self._obsvals)

    def obs_min(self):
        return min(min(z) for z in self._obsvals)

    def plot(self, omin, omax):
        self._obsvals.append(numpy.array([omin, omax])) # the min-max dummy
        plot_path_stem = os.path.join(self._outdir,
                             'idealized_interaction_' +str(self._index))
        title = 'Idealized interaction,'
        for m,p,v in self._mods:
            title +='\nModerator %s = %.3g (%.2gth percentile)' \
                     % (m, float(v), 100*float(p))
        fig = _plot_with_legend(title, self._obsvals, self._obsnames)
        canvas = matplotlib.backends.backend_agg.FigureCanvasAgg(fig)
        canvas.print_figure(filename=plot_path_stem + '.eps')
        canvas.print_figure(filename=plot_path_stem + '.png')


def gen_ideal_behavior_plots(args):
    'Loop through given directories, validate files, outsource the plotting.'
    ide = []
    for d in glob.iglob(os.path.join(args.charmod_dirname, '*')):
        with open(os.path.join(d, 'moderator_info.txt')) as fmod:
#           names of the moderators
            modnames = fmod.readline().split()
#           percentiles of the moderators in this plot
            modptils = fmod.readline().split()
#           values of the moderators in this plot
            modvalus = fmod.readline().split()
        ties_log.log_debug('modnames: ' + str(modnames) + '\nmodptils: '
                + str(modptils) + '\nmodvalues: ' + str(modvalus) + '\n')
        if len(modnames) < 1:
            raise Exception('Not enough moderator names from ' + str(modnames))
        if len(modnames) != len(modptils):
            raise Exception('Incompatible number of percentiles: '
                             + str(modnames) + ' ' + str(modptils))
        if len(modvalus) != len(modnames):
            raise Exception('Incompatible number of mod values: '
                            + str(modnames) + ' ' + str(modvalus))
        with open(os.path.join(d, 'obs_states.txt')) as fstat:
#           names of observables, line 1
            obsnames = fstat.readline().split()
#           values of observbs, lines 2+
            obsvals = [l.split() for l in fstat]
        ties_log.log_debug('obsnames: ' + str(obsnames) + '\n')
        if len(obsnames) < 1:
            raise Exception('Not enough observables from ' + str(obsnames))
        if len(obsnames) != min(len(l) for l in obsvals):
            raise Exception('Observable table has a too-small row:\n'
                            + repr(obsvals))
        if len(obsnames) != max(len(l) for l in obsvals):
            raise Exception('Observable table has a too-big row:\n'
                            + repr(obsvals))
        ide.append(IdealizedDyad(zip(modnames, modptils, modvalus), obsnames,
                        obsvals, args.output_dir_plots, os.path.basename(d)))

#   We want the y axis be the same for all plots.
#   These two lines find global min and max values so we can do that.
    iomax = max(i.obs_max() for i in ide)
    iomin = min(i.obs_min() for i in ide)

    for i in ide:
        i.plot(iomin, iomax)


def arg_is_dir(a):
    return a is not None and os.path.isdir(a)


if __name__ == '__main__':
    log_pid = ties_log.start_log_with_args()
    try:
        args = _build_im_parser().parse_args()
        if not arg_is_dir(args.output_dir_plots):
            raise Exception('plots directory missing or bad')
        if not arg_is_dir(args.charmod_dirname):
            raise Exception('model directory missing or bad')
        ties_log.log_debug(repr(args))
        gen_ideal_behavior_plots(args)
    finally:
        ties_log.stop_hourly_top_log(log_pid)

