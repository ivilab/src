################################################################################
# 
# Build scripts  
# =============
#
# This file (${IVI_SRC_PATH}Make/scripts/build-2) is sourced by the script "build"
# after it has determined the value of IVI_SRC_PATH. In order to be able to move src
# directories without problem, each source directory has a copy of the script
# "build", but once IVI_SRC_PATH is known, then we know where to find the build
# tools. 
#
# The main purpose of the build scripts is to normalize the make environment,
# and to implement some functionality that is difficult to do in a robust
# portable way for all flavors of make. 
#
##################################################################################

if ($?IVI_SET_ECHO) set echo 

${VERBOSE_ECHO} "Entering script build-2 in ${cwd}."

if ($?IVI_HAVE_MACHINE) then
    ${VERBOSE_ECHO_2} "Script build-2 is not sourcing ${MAKE_PATH}init_machine because IVI_HAVE_MACHINE is set."
else 
    ${VERBOSE_ECHO} "Script build-2 is sourcing ${MAKE_PATH}init_machine."

    source ${MAKE_PATH}init_machine
    if ($status) exit $status
endif 

##################################################################################
#
#                      Manipulating the build
#                      ----------------------
#
# Build options can be manipulated by changing environment variables, some of
# which are documented in this file. If you prefer, these can be set in the
# BUILD_ENV* files. One way to get started with this plan is to copy
# ${IVI_SRC_PATH}Make/BUILD_ENV.example into your program directory as
# BUILD_ENV, possibly with suffixes for the OS or user name. 
#
# Since all IVI code should really share most such settings (espeicially BOOST
# oriented ones), we first source ones in Make, then then current directory,
# which thus can over-ride. 

set shared_build_env_files = "BUILD_ENV BUILD_ENV.${OS} BUILD_ENV.${MACHINE} BUILD_ENV.${SHORT_HOST} BUILD_ENV.${OS}"

if ("${OS2}" != "") then 
    set shared_build_env_files = "${shared_build_env_files} BUILD_ENV.${OS}${OS2} BUILD_ENV.${OS}${OS2}_${CPU}"
endif 

set build_env_files = ""

foreach shared_build_env_file (${shared_build_env_files}) 
    set build_env_files = "${build_env_files} ${shared_build_env_file}"

    if ($?USER) then
        set build_env_files = "${build_env_files} ${shared_build_env_file}.${USER}"
    endif 
end

${VERBOSE_ECHO} "Checking for build option files in (${build_env_files})."
${VERBOSE_ECHO} "First we check for them in ${MAKE_PATH}, then the current directory."

set paths_for_build_env = "${MAKE_PATH} ./"

foreach path_for_build_env (${paths_for_build_env})
    foreach build_env_file (${build_env_files})
        set build_env_file = "${path_for_build_env}${build_env_file}"
        if (-e "${build_env_file}") then
            ${VERBOSE_ECHO} "Sourcing ${build_env_file} in directory ${cwd}, which can overide shell settings."
            source ${build_env_file}
            ${VERBOSE_ECHO} "Back from ${build_env_file} in directory ${cwd}."
            if (${status}) exit 1
        else if ($?IVI_VERBOSE_2) then
            ${VERBOSE_ECHO_2} "No optional build file ${build_env_file} in directory ${cwd}."
        endif 
    end
end

##################################################################################

${VERBOSE_ECHO} "Script build-2 is sourcing ${MAKE_PATH}init_compile"

set found_workable_boost = 0 

if ($?IVI_BOOST_VERSION) then
    if ("${IVI_BOOST_VERSION}" != "") then
        set boost_candidates = `echo ${IVI_BOOST_VERSION} | sed 's/:/ /g'`

        foreach boost_candidate (${boost_candidates}) 
            ${VERBOSE_ECHO} "Script build-2 is trying boost_candidate ${boost_candidate} by setting IVI_BOOST_VERSION to that and sourcing init_compile."
            setenv IVI_BOOST_VERSION "${boost_candidate}"

            source ${MAKE_PATH}init_compile
            if (${status}) then
                ${VERBOSE_ECHO} "Script build-2 did not find boost_candidate ${boost_candidate}."
            else
                ${ECHO_UNLESS_QUIET} "Script build-2 accepting boost_candidate ${boost_candidate}."
                set found_workable_boost = 1
                break
            endif 
        end

        if (! ${found_workable_boost}) then
            echo "Not able to find any of the boost candidates in (${boost_candidates})."
            echo "Setting environment variable NO_BOOST and sourcing init_compile one more time."
            echo "Likely things will break, even though they should not (under CONSTRUCTION)."
            setenv NO_BOOST 1
            unsetenv IVI_BOOST_VERSION
        endif
    endif
endif 
            
# We would only have boost at this point if we looked for it due to
# IVI_BOOST_VERSION. So, typically, found_workable_boost is false and we go into
# the "if" block.

if (! ${found_workable_boost}) then
    source ${MAKE_PATH}init_compile
    if (${status}) then
        echo "Sourcing ${MAKE_PATH}init_compile returned failure."
        exit 1
    endif 
endif 

setenv CWD "${cwd}"

################################################################################

# BUILD_BIN_PATH cannot be null, otherwise, Makefile-program will use it to
# create a rule for "./", which will be executed, and fail.
#
if (! $?BUILD_BIN_PATH) then
    setenv BUILD_BIN_PATH ${USER_BIN_PATH}
endif

# Options to manipulate the parallel build of sub_libs_needed. Tweak for
# performance, but should be somewhat a function of the machine. 

# Expensive, so we only set when we are really interested. Set by default, if we
# are asking for debug information.
#
if ($?IVI_DEBUG) then
    setenv TRACK_PROCESS_COUNTS
endif 

# How deep do we recurse before we declare that we should not fork any more
# building in the background? 
#
if (! $?SERIAL_RECURSION_LEVEL) then
    setenv SERIAL_RECURSION_LEVEL 3
endif 

# How many processes do we put in the background at a time? The actual total
# number of processes in the background can be a lot bigger due to recurssion
# and parallelism. Any number greater than the number of IVI sub libs (about
# 110) is effectively infinity. On my summer 2020 mac, anything greater than
# NUM_CPU gets into diminishing returns. 
#
if (! $?MAX_BACKGROUND_CHILDREN) then
    @ max_background_children = ${NUM_CPU}
    
    # Going over 24 starts to incur a lot of overhead on Laplace.
    if (${max_background_children} > 24) @ max_background_children = 24

    setenv MAX_BACKGROUND_CHILDREN ${max_background_children}
endif 

################################################################################

if ($?IVI_VERBOSE) then
   set suppress_jobserver_msg = " cat "
else if ( $?IVI_QUIET ) then
   # Get ride of some annoying messages. However, this is a hack.  We cannot use
   # grep because it can exit with 1. We also have yet to control how spaces in
   # the search string can get parsed properly. So we do without for now. 
   set suppress_jobserver_msg = ' sed /jobserver/d' 
else 
   set suppress_jobserver_msg = ' sed /jobserver/d' 
endif 

################################################################################

# We adjust the build and the compile for things like output control because it
# is not reasonable to have a special cache or compile dir for them as the
# object code should not change. But then, switching the effect in init_compile
# cannot work (very well). 

set make_extra_opts = ""

if ($?IVI_MAKE_DEBUG) then 
    set make_extra_opts = "${make_extra_opts} ${IVI_MAKE_OPTS_DEBUG}"
endif 

if ($?FORCE_STOP) then
    ${VERBOSE_ECHO} "Forcing stopping after an error due to env var FORCE_STOP being set"
    set make_extra_opts = "${make_extra_opts} ${IVI_MAKE_OPTS_STOP}"
endif 

if ($?IVI_QUIET) then
    set make_extra_opts = "${make_extra_opts} ${IVI_MAKE_OPTS_SILENT}"
    setenv SUPPRESS_IF_QUIET '>& /dev/null'
endif 

setenv IVI_MAKE_SERIAL "${IVI_MAKE_SERIAL} ${make_extra_opts}"
setenv IVI_MAKE_PAR    "${IVI_MAKE_PAR} ${make_extra_opts}"

if ($?FORCE_SERIAL) then
    # The following two env vars could be set by the user to build only
    # sub_libs_needed serially. But we also force it if we building everything
    # serially.
    #
    setenv BUILD_SUB_LIBS_SERIAL
    setenv BUILD_FILE_LISTS_SERIAL

    if ($?IVI_VERBOSE) then
        echo "Forcing serial make due to env var FORCE_SERIAL being set"
    endif 

    setenv IVI_MAKE "${IVI_MAKE_SERIAL}"
else 
    setenv IVI_MAKE "${IVI_MAKE_PAR}"
endif  

################################################################################

if ($?FORCE_C99) then
    setenv CC_BASE_FLAGS "${CC_C99_BASE_FLAGS}" 
else if ($?FORCE_C89) then
    setenv CC_BASE_FLAGS "${CC_C89_BASE_FLAGS}" 
else if ($?FORCE_NULL_STD) then
    setenv CC_BASE_FLAGS "${CC_NULL_STD_BASE_FLAGS}" 
endif 

################################################################################

# The default warn level is set to 2 in init_scripts. To simplify changing the
# warn level, we check it every time, which is a bit excessive. However, it is
# better than forcing cleaning the cache. Changes here should be paralleled in
# init_compile (being phased out!). 

# IVI_CC_WARN_LEVEL allows us to override the warn level in case of C code. 
if (! $?IVI_CC_WARN_LEVEL) then
    setenv IVI_CC_WARN_LEVEL ${IVI_WARN_LEVEL}
endif 

if (${IVI_CC_WARN_LEVEL} == 0) then
    setenv CC_IVI_WARNINGS "${CC_IVI_WARN_0}"
else if (${IVI_CC_WARN_LEVEL} == 1) then
    setenv CC_IVI_WARNINGS "${CC_IVI_WARN_1}"
else if (${IVI_CC_WARN_LEVEL} == 2) then
    setenv CC_IVI_WARNINGS "${CC_IVI_WARN_2}"
else if (${IVI_CC_WARN_LEVEL} == 3) then
    setenv CC_IVI_WARNINGS "${CC_IVI_WARN_3}"
else if (${IVI_CC_WARN_LEVEL} == 4) then
    setenv CC_IVI_WARNINGS "${CC_IVI_WARN_4}"
else if (${IVI_CC_WARN_LEVEL} >= 5) then
    setenv CC_IVI_WARNINGS "${CC_IVI_WARN_5}"
endif 

if (${IVI_WARN_LEVEL} == 0) then
    setenv CXX_IVI_WARNINGS "${CXX_IVI_WARN_0}"
    setenv F77_IVI_WARNINGS "${F77_IVI_WARN_0}"
    setenv IVI_CXX_MESSAGE_FILTER "${IVI_CXX_DEFAULT_MSG_FILTER}"
else if (${IVI_WARN_LEVEL} == 1) then
    setenv CXX_IVI_WARNINGS "${CXX_IVI_WARN_1}"
    setenv F77_IVI_WARNINGS "${F77_IVI_WARN_1}"
    setenv IVI_CXX_MESSAGE_FILTER "${IVI_CXX_DEFAULT_MSG_FILTER}"
else if (${IVI_WARN_LEVEL} == 2) then
    setenv CXX_IVI_WARNINGS "${CXX_IVI_WARN_2}"
    setenv F77_IVI_WARNINGS "${F77_IVI_WARN_2}"
    setenv IVI_CXX_MESSAGE_FILTER "${IVI_CXX_DEFAULT_MSG_FILTER}"
else if (${IVI_WARN_LEVEL} == 3) then
    setenv CXX_IVI_WARNINGS "${CXX_IVI_WARN_3}"
    setenv F77_IVI_WARNINGS "${F77_IVI_WARN_3}"
    setenv IVI_CXX_MESSAGE_FILTER "${IVI_CXX_DEFAULT_MSG_FILTER}"
else if (${IVI_WARN_LEVEL} == 4) then
    setenv CXX_IVI_WARNINGS "${CXX_IVI_WARN_4}"
    setenv F77_IVI_WARNINGS "${F77_IVI_WARN_4}"
    setenv IVI_CXX_MESSAGE_FILTER "${IVI_CXX_ALLPASS_MSG_FILTER}"
else if (${IVI_WARN_LEVEL} >= 5) then
    setenv CXX_IVI_WARNINGS "${CXX_IVI_WARN_5}"
    setenv F77_IVI_WARNINGS "${F77_IVI_WARN_5}"
    setenv IVI_CXX_MESSAGE_FILTER "${IVI_CXX_ALLPASS_MSG_FILTER}"
endif 

if ($USE_SHARED_WARNINGS) then 
    setenv CC_SHARED_WARNINGS "${CC_IVI_WARNINGS}"
else 
    setenv CC_SHARED_WARNINGS "${CC_IVI_WARN_0}"
endif 

################################################################################

set is_parallel = 0
set have_job_arg = `echo ${IVI_MAKE} | grep -c '\-j [1-9]'`
if (${have_job_arg}) then
    set job_arg_val = `echo ${IVI_MAKE} | sed 's/^.*-j \([1-9][0-9]*\)[^0-9]*$/\1/'`
    if (${job_arg_val} > 1) then
        set is_parallel = 1
    endif 
endif 

################################################################################

if ($?IVI_VERBOSE_2) then
    ${VERBOSE_ECHO_2} "" 
    ${VERBOSE_ECHO_2} =================  variable values in build-2 =========================
    ${VERBOSE_ECHO_2} "" 

    ${VERBOSE_ECHO_2} "SHORT_HOST:              ${SHORT_HOST}"
    ${VERBOSE_ECHO_2} "MACHINE:                ${MACHINE}"
    ${VERBOSE_ECHO_2} "OS:                     ${OS}"
    ${VERBOSE_ECHO_2} "OS2:                    ${OS2}"

    if ($?UBUNTU_RELEASE) then
        ${VERBOSE_ECHO_2} "UBUNTU_RELEASE:         ${UBUNTU_RELEASE}"
    endif 

    ${VERBOSE_ECHO_2} " "
    ${VERBOSE_ECHO_2} "SHELL_FOR_MAKE:         ${SHELL_FOR_MAKE}"
    ${VERBOSE_ECHO_2} "CWD:                    ${CWD}"
    ${VERBOSE_ECHO_2} "IVI_SRC_PATH:           ${IVI_SRC_PATH}"
    ${VERBOSE_ECHO_2} "IVI_LIB_PATH:           ${IVI_LIB_PATH}"
    ${VERBOSE_ECHO_2} "MAKE_PATH:              ${MAKE_PATH}"
    ${VERBOSE_ECHO_2} "MAKE_SCRIPT_PATH:       ${MAKE_SCRIPT_PATH}"
    ${VERBOSE_ECHO_2} "MAKE_FLAVOR:            ${MAKE_FLAVOR}"
    ${VERBOSE_ECHO_2} "IVI_DIFF_TEST:          ${IVI_DIFF_TEST}"
    ${VERBOSE_ECHO_2} "IVI_STAT_FLAVOR:        ${IVI_STAT_FLAVOR}"
    ${VERBOSE_ECHO_2} "VIM_FOR_MAKE:           ${VIM_FOR_MAKE}"
    ${VERBOSE_ECHO_2} "VIM_SUFFIX:             ${VIM_SUFFIX}"
    ${VERBOSE_ECHO_2} "PRODUCTION:             ${PRODUCTION}"
    ${VERBOSE_ECHO_2} "OBJ_DIR:                ${OBJ_DIR}"
    ${VERBOSE_ECHO_2} "CXX_OBJ_DIR:            ${CXX_OBJ_DIR}"
    ${VERBOSE_ECHO_2} "LD_OBJ_DIR:             ${LD_OBJ_DIR}"
    ${VERBOSE_ECHO_2} "REAL_OBJ_DIR:           ${REAL_OBJ_DIR}"
    ${VERBOSE_ECHO_2} "LOAD_DIRS:              ${LOAD_DIRS}"
    ${VERBOSE_ECHO_2} "" 
    ${VERBOSE_ECHO_2} "IVI_DOC_PATH:           ${IVI_DOC_PATH}"
    ${VERBOSE_ECHO_2} "MAN3_MAN_PATH:          ${MAN3_MAN_PATH}"
    ${VERBOSE_ECHO_2} "HTML_MAN_PATH:          ${HTML_MAN_PATH}"
    ${VERBOSE_ECHO_2} "CAT3_MAN_PATH:          ${CAT3_MAN_PATH}"
    ${VERBOSE_ECHO_2} "PROGRAM_MAN_PATH:       ${PROGRAM_MAN_PATH}"
    ${VERBOSE_ECHO_2} "PROGRAM_CAT_PATH:       ${PROGRAM_CAT_PATH}"
    ${VERBOSE_ECHO_2} "" 
    ${VERBOSE_ECHO_2} "IVI_WARN_LEVEL:         ${IVI_WARN_LEVEL}"
    ${VERBOSE_ECHO_2} "IVI_CC_WARN_LEVEL:      ${IVI_CC_WARN_LEVEL}"
    ${VERBOSE_ECHO_2} "CC_IVI_WARNINGS:        ${CC_IVI_WARNINGS}"
    ${VERBOSE_ECHO_2} "CXX_IVI_WARNINGS:       ${CXX_IVI_WARNINGS}"
    ${VERBOSE_ECHO_2} "IVI_CXX_MESSAGE_FILTER: ${IVI_CXX_MESSAGE_FILTER}"
    ${VERBOSE_ECHO_2} "ECHO_IF_VERBOSE;        ${ECHO_IF_VERBOSE}" 
    ${VERBOSE_ECHO_2} "" 
    ${VERBOSE_ECHO_2} "ALL_BASE_INCLUDES:      ${ALL_BASE_INCLUDES}"
    ${VERBOSE_ECHO_2} "LIB_BASE_INCLUDES:      ${LIB_BASE_INCLUDES}"
    ${VERBOSE_ECHO_2} "DEFAULT_OPT_INCLUDES:   ${DEFAULT_OPT_INCLUDES}"
    ${VERBOSE_ECHO_2} "LOAD_DIRS:              ${LOAD_DIRS}"
    ${VERBOSE_ECHO_2} "IVI_ACTUAL_BOOST:       ${IVI_ACTUAL_BOOST}"
    ${VERBOSE_ECHO_2} "" 
    ${VERBOSE_ECHO_2} "Job client make:        ${IVI_MAKE_JOB_CLIENT}" 
    ${VERBOSE_ECHO_2} "Serial make command:    ${IVI_MAKE_SERIAL}" 
    ${VERBOSE_ECHO_2} "Parallel make command:  ${IVI_MAKE_SERIAL}" 
    ${VERBOSE_ECHO_2} "Default make is parallel: ${is_parallel}" 
    ${VERBOSE_ECHO_2} "Default make command:   ${IVI_MAKE}" 
    ${VERBOSE_ECHO_2} "" 
    ${VERBOSE_ECHO_2} ==================================================================================
    ${VERBOSE_ECHO_2} "" 
endif 

################################################################################

# We may just be sourcing this script via sourcing build just to get the
# environment. However, argv, might already be set in the calling script, and
# probably should not be disturbed. So, we want another way to exit now. 
# (This is a hack, and probably should be fixed.)

if ($?ONLY_GET_BUILD_ENV) exit

################################################################################

# This is somewhat misleading. We never get anything other than 1 argument when
# this is called via "Make"(*). Also, if the user simply enters "make", we will
# get the argument "all" due to way we ask make to call this script. However, we
# might want to call this script directly on occasion, so we keep the capability
# of dealing with any number of arguments.
#
# (*) To finish the story, if we call make with multiple arguments, then make will
# call us with each of those arguments separately, either serially or in parallel,
# depending on options given to make. 

set num_args = $#argv

if (${num_args} == 0) then
    set args = ""
#     set argv = "all"
#     set num_args = 1
else 
    set args = "$*"
endif 

if (! $?IVI_QUIET ) then
    set start_time = `${IVI_ECHO_TIME}`

    echo " "
    echo "Build start for '${args}' at ${start_time} in ${cwd}"
    echo " "
endif 

################################################################################

setenv VERBOSE_INDENT ""

if (! $?IVI_QUIET ) then
    set build_verbose = 1
else 
    set build_verbose = 0
endif 

################################################################################

# It is OK if TMP_SUB_DIRS_VISITED is not set, but if it is set to a list of sub
# direcotory names for some bizarre reason, then things might break. 
#
setenv TMP_SUB_DIRS_VISITED ""

################################################################################

# Currently, at least for me (Kobus), the error messages from gcc are a bit
# screwed up due to some LOCALE inconsistency. Until I get time to figure it
# out, we will just have gcc run in the simplest local environment. 
#
setenv LC_ALL C 

################################################################################

set save_production = "${PRODUCTION}"
set save_ivi_cc = "${IVI_CC}"

# Check for obsolete files that could confuse things. 
if (-e "Makefile-depend") then
    set old_rule = `cat Makefile-depend | grep -c 'Makefile-depend : input'`
    if (! ${old_rule} ) then
        set old_rule = `cat Makefile-depend | grep -c 'Makefile-depend : test_input'`
    endif 

    if (${old_rule}) then 
        if ($?IVI_VERBOSE) then
            echo "Script build-2 is removing an obsolete Makefile-depend."
        endif 
        ${IVI_RM} Makefile-depend
    endif 
endif  

# Some targets we allow TARGET_TYPE.PROGRAM and want it to mean the same thing
# as PROGRAM.TARGET_TYPE. We want deal with the TARGET_TYPE.PROGRAM format
# initially, even though for TARGETS_TYPE in test_target_suffixes we switch the
# order (potentially twice) for make.
#
set test_target_prefixes = "test regress test_svn"
set test_target_suffixes = "test_clean test_invalid test_very_clean regress_clean"

# Helps get around substitution rules.
set dollar = '$'

set adjusted_args = ""
set count = 1

set need_depend_bootstrap = 0
set need_depend = 0

while ($count <=  ${num_args}) 
    set arg = $argv[${count}]

    foreach test_target_type (${test_target_prefixes} ${test_target_suffixes})
        set part_one = `echo $arg | sed "s/\.${test_target_type}${dollar}//"`
        if ("${part_one}" != "${arg}") then
            ${VERBOSE_ECHO} "Changing arg '${arg}' to '${test_target_type}.${part_one}'"
            set arg = "${test_target_type}.${part_one}"
            break
        endif
    end

    foreach test_target_type (${test_target_prefixes} ${test_target_suffixes})
        set next_arg = `echo $arg | sed "s/${test_target_type}\.//"`
        if ("${next_arg}" != "${arg}") then
            ${VERBOSE_ECHO} "Breaking arg '${arg}' into '${test_target_type}' and '${next_arg}'"
            set arg = "${test_target_type}"
            break
        else 
            set next_arg = ""
        endif 
    end

    @ count ++

    # If multiple make targets are being processed, then we need to make sure
    # that ones that forced settings do not affect the others. 
    #
    if (("${PRODUCTION}" != "${save_production}") || ("${IVI_CC}" != "${save_ivi_cc}")) then
        setenv IVI_CC "${save_ivi_cc}" 
        setenv PRODUCTION "${save_production}"
        source ${MAKE_PATH}init_compile
    endif 

    if ("${arg}" == "all") then
        set need_depend = 1
        # Do nothing special. Common case that would fall through, but we skip
        # all the processing. 
    else if ("${arg}" == "bin") then
        set need_depend = 1

        # The default is USER_BIN_PATH, but the user can set BUILD_BIN_PATH to
        # anything they want to over ride this default. 
        #
        if (! $?BUILD_BIN_PATH) then
            setenv BUILD_BIN_PATH "${USER_BIN_PATH}"
        endif 
    else if ("${arg}" == "misc_bin") then
        set need_depend = 1
        setenv BUILD_BIN_PATH "${MISC_BIN_PATH}"
        set arg = "bin"
    else if ("${arg}" == "make_bin") then
        set need_depend = 1
        setenv BUILD_BIN_PATH "${MAKE_BIN_PATH}"
        set arg = "bin"
    else if ("${arg}" == "ivi_code") then
        # We do IVI and IVI_cpp first, which is completely optional, as this
        # manages the parallel build of the basic code more efficiently than
        # make_ivi, which would also build it, but checks the build of
        # additional code (.e.g., test code). 
        #

        # No DRY_RUN as this is temporary development.

#         pushd ${IVI_SRC_PATH}IVI > /dev/null
#             make depend_very_clean
#             if ($status) exit 1 
#             make depend
#             if ($status) exit 1 
#             make clean 
#             if ($status) exit 1 
#             make 
#             if ($status) exit 1 
#         popd > /dev/null
# 
#         pushd ${IVI_SRC_PATH}IVI_cpp > /dev/null
#             make depend_very_clean
#             if ($status) exit 1 
#             make depend
#             if ($status) exit 1 
#             make clean 
#             if ($status) exit 1 
#             make 
#             if ($status) exit 1 
#         popd > /dev/null
        
        set make_cmd = "${MAKE_SCRIPT_PATH}make_ivi ivi ivi_cpp skip_doc skip_tags skip_depend skip_regress skip_no_libs skip_prog_no_libs skip_prog_dirs"
        if ($?DRY_RUN) then
            echo "DRY: ${make_cmd}"
        else
            ${make_cmd}
            if (${status}) exit 1
        endif 

        continue
    else if ("${arg}" == "ivi_doc") then
        # No DRY_RUN as this is temporary development.

#         pushd ${MAKE_SCRIPT_PATH} > /dev/null
#             make doc 
#             if ($status) exit 1 
#         popd > /dev/null
# 
#         # We need to get IVI and IVI_cpp to make C/C++ documentation because
#         # that is currently the only place where we build the index. The script
#         # make_ivi does not know about any more directories for documentation,
#         # so we do not need to use it. 
#         #
#         pushd ${IVI_SRC_PATH}IVI > /dev/null
#             make doc 
#             if ($status) exit 1 
#         popd > /dev/null
# 
#         pushd ${IVI_SRC_PATH}IVI_cpp > /dev/null
#             make doc 
#             if ($status) exit 1 
#         popd > /dev/null

        set make_cmd = "${MAKE_SCRIPT_PATH}make_ivi doc skip_code skip_tags skip_depend skip_regress skip_no_libs skip_prog_no_libs skip_prog_dirs"
        if ($?DRY_RUN) then
            echo "DRY: ${make_cmd}"
        else
            ${make_cmd}
            if (${status}) exit 1
        endif

        continue
    else if ("${arg}" == "ivi_tags") then
#         # We do IVI and IVI_cpp first, which is completely optional, for speed.
#         pushd ${IVI_SRC_PATH}IVI > /dev/null
#             make tags 
#             if ($status) exit 1 
#         popd > /dev/null
# 
#         pushd ${IVI_SRC_PATH}IVI_cpp > /dev/null
#             make tags 
#             if ($status) exit 1 
#         popd > /dev/null

        set make_cmd = "${MAKE_SCRIPT_PATH}make_ivi tags ivi ivi_cpp skip_code skip_doc skip_depend skip_regress skip_no_libs skip_prog_no_libs skip_prog_dirs"
        if ($?DRY_RUN) then
            echo "DRY: ${make_cmd}"
        else
            ${make_cmd}
            if (${status}) exit 1
        endif

        continue
    else if ("${arg}" == "ivi_regress") then
        set make_cmd = "${MAKE_SCRIPT_PATH}make_ivi regress skip_doc skip_tags skip_depend skip_no_libs skip_prog_no_libs skip_prog_dirs"
        if ($?DRY_RUN) then
            echo "DRY: ${make_cmd}"
        else
            ${make_cmd}
            if (${status}) exit 1
        endif
        
        continue
    else if ("${arg}" == "ivi_depend") then
        set make_cmd = "${MAKE_SCRIPT_PATH}make_ivi skip_doc skip_tags skip_regress skip_no_libs skip_prog_no_libs skip_prog_dirs"
        if ($?DRY_RUN) then
            echo "DRY: ${make_cmd}"
        else
            ${make_cmd}
            if (${status}) exit 1
        endif

        continue
    else if ("${arg}" == "confess") then
        if (! $?IVI_VERBOSE) then
            setenv IVI_VERBOSE 1
            set reset_no_verbose = 1
        else
            set reset_no_verbose = 0
        endif
        
        echo " "
        echo "Cleaning the cache because of target confess."
        echo " "

        source ${MAKE_SCRIPT_PATH}clean_cache
        source ${MAKE_PATH}init_compile

        if (${reset_no_verbose}) then
            unsetenv IVI_VERBOSE
        endif 

        continue
    else if ( ("${arg}" == "cache_clean") || ("${arg}" == "clean_cache") || ("${arg}" == "init_clean") ) then
        set make_cmd = "source ${MAKE_SCRIPT_PATH}clean_cache"
        if ($?DRY_RUN) then
            echo "DRY: ${make_cmd}"
        else
            ${make_cmd}
            if (${status}) exit 1
        endif
        
        continue
    else if (("${arg}" == "locks_clean") || ("${arg}" == "clean_locks")) then
        set make_cmd = "source ${MAKE_SCRIPT_PATH}clean_locks"
        if ($?DRY_RUN) then
            echo "DRY: ${make_cmd}"
        else
            ${make_cmd}
            if (${status}) exit 1
        endif
        
        continue
    else if (("${arg}" == "depend_dirs") || ("${arg}" == "depend_dir") || ("${arg}" == "depend_depend")) then
        echo "Argument ${arg} is obsolete. Proceeding as though it were 'depend'."
        set need_depend = 1
        set arg = depend
    else if ("${arg}" == "depend")  then
        set need_depend = 1
    else if ("${arg}" == "code") then
        # We have the target "code" to do "all" without any depend stuff. So no
        # setting of "need_depend". 
        set arg = all
    else if ("${arg}" == "obj_clean") then
        echo " "
        echo "Build script is cleaning up object directories in the current directory and below."
        echo " "

        set make_cmd = "source ${MAKE_SCRIPT_PATH}clean_obj"
        if ($?DRY_RUN) then
            echo "DRY: ${make_cmd}"
        else
            ${make_cmd}
            if (${status}) exit 1
        endif

        continue
    else if ("${arg}" == "depend_very_clean") then
        echo " "
        echo "Build script is cleaning up Makefiles in current dir, lib, and all IVI libs."
        echo " "

        set make_cmd = "source ${MAKE_SCRIPT_PATH}clean_global"
        if ($?DRY_RUN) then
            echo "DRY: ${make_cmd}"
        else
            ${make_cmd}
            if (${status}) exit 1
        endif

        continue
    else if ("${arg}" == "depend_clean") then
        echo " "
        echo "Build script is cleaning up Makefiles in current dir (only)."
        echo " "
        
        set make_cmd = "source ${MAKE_SCRIPT_PATH}clean_local"
        if ($?DRY_RUN) then
            echo "DRY: ${make_cmd}"
        else
            ${make_cmd}
            if (${status}) exit 1
        endif
  
        continue
    else if (("${arg}" == "static") || ("${arg}" == "dynamic") || ("${arg}" == "shared")) then
        set need_depend = 1
 
        if ("${arg}" == "dynamic") then
            if (! $?IVI_QUIET ) then
                echo ""; echo "Build script is switching target dyanamic to 'shared'"; echo ""
                set arg = "shared"
            endif
        endif 

    else if ("${arg}" == "doc") then
        set need_depend = 1
        set have_cpp = `${MAKE_SCRIPT_PATH}stream_file_names -doxygen -t`
        
        if ("${have_cpp}" == "1") then
            echo "Changing target doc to doxygen."
            set arg = doxygen
        endif 
    else if ("${arg}" == "test") then
        # No need_depend because the test Makefiles are separated. But they do
        # include Makefile-program, and so best to ensure that included files
        # such as Makefile-dirs exist.  
        set need_depend_bootstrap = 1

        if ("${next_arg}" != "") then
            set arg = ""
            set prog = `echo ${next_arg} | sed 's/\(.*\)\.c.*$/\1/'`

            if (-d "test_input/${prog}") then
                pushd "test_input/${prog}" > /dev/null 
                set test_instances = `find . -maxdepth 1 -mindepth 1 -type d \! \( -name '.*' \) |& sed 's#./##'`
                popd > /dev/null

                foreach test_instance (${test_instances})
                    set arg = "${arg} test_runs/${prog}/${test_instance}/test/${TEST_CODE_TYPE}/output_checked"
                end
            endif

            if ("${arg}" == "") then
                ${P_STDERR} "No test instances found for ${prog}"
                ${P_STDERR} " "
                exit 1
            endif 
        endif 
    else if ("${arg}" == "regress") then
        # No need_depend because the test Makefiles are separated. But they do
        # include Makefile-program, and so best to ensure that included files
        # such as Makefile-dirs exist.  
        set need_depend_bootstrap = 1
        if ("${next_arg}" != "") then
            set arg = ""
            set prog = `echo ${next_arg} | sed 's/\(.*\)\.c.*$/\1/'`

            if (-d "test_input/${prog}") then
                pushd "test_input/${prog}" > /dev/null 
                set test_instances = `find . -maxdepth 1 -mindepth 1 -type d \! \( -name '.*' \) |& sed 's#./##'`
                popd > /dev/null

                foreach test_instance (${test_instances})
                    set arg = "${arg} test_runs/${prog}/${test_instance}/regress/${LD_OBJ_DIR}regression_test_passed"
                end
            endif
        endif 
    else if ("${arg}" == "test_svn")  then
        # No need_depend because the test Makefiles are separated. But they do
        # include Makefile-program, and so best to ensure that included files
        # such as Makefile-dirs exist.  
        set need_depend_bootstrap = 1

        if ("${next_arg}" != "") then
            set arg = ""
            set prog = `echo ${next_arg} | sed 's/\(.*\)\.c.*$/\1/'`

            if (-d "test_input/${prog}") then
                pushd "test_input/${prog}" > /dev/null 
                set test_instances = `find . -maxdepth 1 -mindepth 1 -type d \! \( -name '.*' \) |& sed 's#./##'`
                popd > /dev/null

                foreach test_instance (${test_instances})
                    set arg = "${arg} test_runs/${prog}/${test_instance}/test/${TEST_CODE_TYPE}/svn_phony"
                end
            endif

            if ("${arg}" == "") then
                ${P_STDERR} "No test instances found for ${prog}"
                ${P_STDERR} " "
                exit 1
            endif 
        endif 
    else if ( ("${arg}" == "regress")  || ("${arg}" == "regress_clean") )  then
        # Probably need_depend_bootstrap would suffice. 
        set need_depend = 1
    else if (("${arg}" == "test_clean") || ("${arg}" == "test_very_clean") || ("${arg}" == "test_invalid")  || ("${arg}" == "regress_clean"))  then
        set need_depend_bootstrap = 1
        
        # These targets, when qualified, are implemented in Makefile-test using
        # %.SUFFIX, where SUFFIX is one of test_clean, test_very_clean, etc.
        # We want X.Y == Y.X for these, so here we switch the order.
        #
        if ("${next_arg}" != "") then
           set arg = ${next_arg}.${arg}
        endif
    else if ("${arg}" == "file_list") then
        set arg = "file_list.new"
        set need_depend = 1
        if (! $?IVI_QUIET ) then
            echo "Script build-2 is switching target file_list to file_list.new"
        endif 
    else if ("${arg}" == "include_lines") then
        set arg = "include_lines.new"
        set need_depend = 1
        if (! $?IVI_QUIET ) then
            echo "Script build-2 is switching target include_lines to include_lines.new"
        endif 
    else if (("${arg}" == "file_list".new") || ("${arg}" == "include_lines".new")  || ("${arg}" == "depend") || ("${arg}" == "depend_again")) then
        set need_depend = 1
    else
        set need_depend = 1

        set arg_with_dot_c = ""
        set obj_dir = "${OBJ_DIR}" 

        set arg_without_dot_c1 = `echo ${arg} | sed 's/\(.*\)\.c$/\1/'`
        set arg_without_dot_c2 = `echo ${arg} | sed 's/\(.*\)\.cpp$/\1/'`
        set arg_without_dot_c3 = `echo ${arg} | sed 's/\(.*\)\.cxx$/\1/'`
        set arg_without_dot_c4 = `echo ${arg} | sed 's/\(.*\)\.cc$/\1/'`
    
        if (("${arg}" != "${arg_without_dot_c1}") && (-e "${arg}")) then
            set arg_with_dot_c = "${arg}"
            set arg_without_dot_c = "${arg_without_dot_c1}"
        else if (("${arg}" != "${arg_without_dot_c2}") && (-e "${arg}")) then
            set arg_with_dot_c = "${arg}"
            set obj_dir = "${CXX_OBJ_DIR}" 
            set arg_without_dot_c = "${arg_without_dot_c2}"
        else if (("${arg}" != "${arg_without_dot_c3}") && (-e "${arg}")) then
            set arg_with_dot_c = "${arg}"
            set arg_without_dot_c = "${arg_without_dot_c3}"
            set obj_dir = "${CXX_OBJ_DIR}" 
        else if (("${arg}" != "${arg_without_dot_c4}") && (-e "${arg}")) then
            set arg_with_dot_c = "${arg}"
            set arg_without_dot_c = "${arg_without_dot_c4}"
            set obj_dir = "${CXX_OBJ_DIR}" 
        else 
            if ((-e ${arg}.c) && (${OBJ_DIR} != "")) then
                set arg_without_dot_c = "${arg}"
                set arg_with_dot_c = "${arg}.c"
            else 
                foreach suffix (cpp cxx C cc)
                    if ((-e ${arg}.${suffix}) && (${OBJ_DIR} != "")) then
                        set arg_without_dot_c = "${arg}"
                        set arg_with_dot_c = "${arg}.${suffix}"
                        set obj_dir = "${CXX_OBJ_DIR}" 
                        break
                    endif 
                end 
            endif 
        endif 

        if ("${arg_with_dot_c}" == "") then
            if (-e "${arg}.c") then
                set arg_with_dot_c = "${arg}.c"
            else if (-e "${arg}.cpp") then
                set arg_with_dot_c = "${arg}.cpp"
            else if (-e "${arg}.cxx") then
                set arg_with_dot_c = "${arg}.cxx"
            else if (-e "${arg}.cc") then
                set arg_with_dot_c = "${arg}.cc"
            else if (-e "${arg}.C") then
                set arg_with_dot_c = "${arg}.C"
            endif 

            if ("${arg_with_dot_c}" != "") then
                set arg_without_dot_c = "${arg}" 
            endif 
        endif

        if ("${arg_with_dot_c}" != "") then
            set noglob 

            set old_arg = "${arg}"

            set test_main = `${MAKE_SCRIPT_PATH}stream_file_names -m -t ${arg_with_dot_c}`

            if ("${test_main}") then
                set arg = "${LD_OBJ_DIR}${arg_without_dot_c}"
            else
                # A bit of a hack. Currently, our makefiles use full paths for
                # lib dirs, and relative paths for non lib dirs. This is
                # potentially a sign that we need a bit of design adjustment.
                # However, for now, we hack around it for the purpose of
                # switching source file args to object args. 
                #
                set test_lib_dir = `echo ${cwd} | grep -c 'lib/[^/][^/]*$'`

                if (${test_lib_dir}) then
                    set arg = "${cwd}/${obj_dir}${arg_without_dot_c}.o"
                else
                    set arg = "${obj_dir}${arg_without_dot_c}.o"
                endif 
            endif 

            echo "Switching target ${old_arg} to ${arg}"

            unset noglob 
        endif 
    endif 

    if ("${adjusted_args}" != "") then
        set adjusted_args = "${adjusted_args} ${arg}"
    else
        set adjusted_args = "${arg}"
    endif 
end

if (${need_depend}) then
    set need_depend_bootstrap = 1
endif 

if ((! ${need_depend_bootstrap}) && ("${adjusted_args}" == "")) then
    ${VERBOSE_ECHO} "Script build-2 is exiting with success as there is nothing left to do."
    exit
endif 

${VERBOSE_ECHO} "Script build-2 adjusted args is '${adjusted_args}' in ${cwd}."

set make_result_temp_file = "${USER_TEMP_PATH}make.res.$$"

# Needs to be set even though we do not actually use it unless LOG_MAKE is set.
setenv MAKE_LOG_PATH "${cwd}/make_log/`${IVI_ECHO_DATE}`/`${IVI_ECHO_TIME}`/"

if ($?LOG_MAKE) then
    ${IVI_MKDIR} ${MAKE_LOG_PATH}
else 
    set make_log_file = '/dev/null'
endif 

set exit_status = 0
set try_count = 1
while (${try_count} <= 4)
    set makefiles_are_ok = 1

    if (${need_depend_bootstrap}) then
        ${VERBOSE_ECHO} 
        ${VERBOSE_ECHO} ==================================================================================
        ${VERBOSE_ECHO} "Script build-2 is bootstrapping make in ${cwd}" 
        ${VERBOSE_ECHO} "for efficiency and in case our version of make does not build included files."
        ${VERBOSE_ECHO} ""

        set bootstrap_files = `${MAKE_SCRIPT_PATH}stream_file_names -bootstrap`

        ${VERBOSE_ECHO} "Script build-2 bootstrap files: ${bootstrap_files}"

        foreach bootstrap_file (${bootstrap_files}) 
            if (-x "${bootstrap_file}") then
                if ($?DRY_RUN) then
                    echo "DRY: ${MAKE_SCRIPT_PATH}ivi_lock 30 ./${bootstrap_file}"
                else
                    if ($?LOG_MAKE) set make_log_file = "${MAKE_LOG_PATH}${bootstrap_file}_${try_count}.res"
                    ${MAKE_SCRIPT_PATH}ivi_lock 30 ./${bootstrap_file} |& ${IVI_TEE} ${make_log_file}
                    if (${status}) then 
                        set exit_status = 1
                        ${P_STDERR} "Running of ${bootstrap_file} in ${cwd} failed."
                        break
                    endif 
                endif 
            endif 
        end

        # If a bootstrap file run fails, it is not likley that retry will help. 
        if (${exit_status}) break

        if (! -e Makefile-dirs) then
            # This is not needed with gmake, but it is the same thing that gmake
            # would do first so it is OK to keep. 
            #
            # We cannot have an empty Makefile-dirs if we are in a library
            # directory. We need the first part which can be built without
            # Include_lines/sub_libs_needed, although the implementation below builds
            # that also.  Hence if Makefile-dirs does not exist, we need to build it
            # here, especially for versions of make that break when we include
            # non-existent files.
            
            ${VERBOSE_ECHO} ""
            ${VERBOSE_ECHO} ==================================================================================
            ${VERBOSE_ECHO} "Script build-2 is building Makefile-dirs in ${cwd}"
            ${VERBOSE_ECHO} "indirectly using scripts build_file_list and build_include_lines."
            ${VERBOSE_ECHO} ""

            set sub_start_time = `${IVI_ECHO_TIME}`

            if ($?DRY_RUN) then
                echo "DRY: ${MAKE_SCRIPT_PATH}ivi_lock_for_make 60 Makefile-dirs ${MAKE_SCRIPT_PATH}build_file_list"
            else
                # Makefile-dirs is made as a side effect of the following.
                if ($?LOG_MAKE) set make_log_file = "${MAKE_LOG_PATH}build_file_list_${try_count}.res"
                ${MAKE_SCRIPT_PATH}ivi_lock_for_make 60 Makefile-dirs ${MAKE_SCRIPT_PATH}build_file_list |& ${IVI_TEE} ${make_log_file}
                if (${status}) then
                    ${P_STDERR} "Building initial Makefile-dirs with script build_file_list failed."
                    set makefiles_are_ok = 0
                    goto next_try
                endif
            endif 

            ${VERBOSE_ECHO} ""
            ${VERBOSE_ECHO} ==================================================================================
            ${VERBOSE_ECHO} "Script build-2 is precomputing file lists in ${cwd}."
            ${VERBOSE_ECHO} ""

            if ($?DRY_RUN) then
                echo "DRY: ${MAKE_SCRIPT_PATH}ivi_lock 300 ${MAKE_SCRIPT_PATH}precompute_file_lists"
            else
                # No lock because we lock what we need within this script. 
                # ${MAKE_SCRIPT_PATH}ivi_lock 300 ${MAKE_SCRIPT_PATH}precompute_file_lists
                #
                # The sed removes most annoying job control output, specifically the
                # ones that do not loose the new line due to parallel output
                # intertwining. We do not use grep in pipes if we plan to use the
                # exit status, as grep will have exit status 1 if no lines are
                # selected. 
                #
                if ($?LOG_MAKE) set make_log_file = "${MAKE_LOG_PATH}precompute_file_lists_${try_count}.res"
                ${MAKE_SCRIPT_PATH}precompute_file_lists |& ${IVI_SED} '/^\[[1-9]/d' |& ${IVI_TEE} ${make_log_file}
                if (${status}) then
                    ${WARN_ECHO} "Precomputing file lists failed."
                endif
            endif 

            ${VERBOSE_ECHO} ""
            ${VERBOSE_ECHO} ==================================================================================
            ${VERBOSE_ECHO} "Script build-2 is building include lines in ${cwd}."

            if ($?DRY_RUN) then
                echo "DRY: ${MAKE_SCRIPT_PATH}ivi_lock_for_make 60 Makefile-dirs ${MAKE_SCRIPT_PATH}build_include_lines"
            else
                if ($?LOG_MAKE) set make_log_file = "${MAKE_LOG_PATH}build_include_lines_${try_count}.res"
                ${MAKE_SCRIPT_PATH}ivi_lock_for_make 60 Makefile-dirs ${MAKE_SCRIPT_PATH}build_include_lines |& ${IVI_TEE} ${make_log_file}
                if (${status}) then
                    ${P_STDERR} "Building initial Makefile-dirs with script build_include_lines failed."
                    set makefiles_are_ok = 0
                    goto next_try
                endif
            endif 

            set sub_end_time = `${IVI_ECHO_TIME}`
            ${VERBOSE_ECHO} "Script build-2 has finished building Makefile-dirs in advance of calling make."
            ${VERBOSE_ECHO} "Building Makefile-dirs started at: ${sub_start_time}"
            ${VERBOSE_ECHO} "Building Makefile-dirs ended at:   ${sub_end_time}"
        endif

        # Some flavors of make will die if files that are included don't exist.
        # Others like gmake are happy to try to build them for you if it can find a
        # rule after reading in the whole works. If this is the behaviour, it is
        # better for us so we only do this if we are not using gmake, or testing
        # with FORCE_MAKEFILE_CREATION. 
        #
        if (("${MAKE_FLAVOR}" != "gmake") || ($?FORCE_MAKEFILE_CREATION)) then
            ${VERBOSE_ECHO} "Due to non gmake make, or testing with FORCE_MAKEFILE_CREATION: "
            ${VERBOSE_ECHO} "    Script build-2 is asking build_include_lines to build Makefile-libs-needed as it goes."
            ${VERBOSE_ECHO} "    Script build-2 is ensuring the existance of certain Makefiles with old timestamps."

            # This is consulted in build_include_lines_2
            setenv SHADOW_BUILD_MAKEFILE_LIBS 1

            if (! -e Makefile-depend) then
                if ($?DRY_RUN) then
                    echo "DRY: ${IVI_TOUCH_1990} Makefile-depend"
                else
                    ${IVI_TOUCH_1990} Makefile-depend
                    if (${status}) then
                        # If this fails, retrying likely will not help. 
                        set exit_status = 1
                        ${P_STDERR} "Touching Makefile-depend in the past failed."
                        break 
                    endif
                endif
            endif

            if (! -e Makefile-libs-needed) then
                if ($?DRY_RUN) then
                    echo "DRY: ${IVI_TOUCH_1990} Makefile-libs-needed"
                else
                    ${IVI_TOUCH_1990} Makefile-libs-needed
                    if (${status}) then
                        # If this fails, retrying likely will not help. 
                        set exit_status = 1
                        ${P_STDERR} "Touching Makefile-libs-needed in the past failed."
                        break 
                    endif
                endif
            endif

            if (-e Makefile-include) then
                if (! -e Makefile-library) then
                    if ($?DRY_RUN) then
                        echo "DRY: ${IVI_TOUCH_1990} Makefile-library"
                    else
                        ${IVI_TOUCH_1990} Makefile-library
                        if (${status}) then
                            # If this fails, retrying likely will not help. 
                            set exit_status = 1
                            ${P_STDERR} "Touching Makefile-library in the past failed."
                            break 
                        endif
                    endif 
                endif 

                if (! -e Include_lines/Makefile-include-lines) then
                    if ($?DRY_RUN) then
                        echo "DRY: ${IVI_MKDIR} Include_lines"
                        echo "DRY: ${IVI_TOUCH_1990} Include_lines/Makefile-include-lines"
                    else
                        ${IVI_MKDIR} Include_lines
                        if (${status}) then
                            # If this fails, retrying likely will not help. 
                            set exit_status = 1
                            ${P_STDERR} "${IVI_MKDIR} Include_lines failed."
                            break 
                        endif

                        ${IVI_TOUCH_1990} Include_lines/Makefile-include-lines
                        if (${status}) then
                            # If this fails, retrying likely will not help. 
                            set exit_status = 1
                            ${P_STDERR} "Touching Include_lines/Makefile-include-lines in the past failed."
                            break 
                        endif
                    endif 
                endif 

                if (! -e Include_lines/Makefile-depend-incl-dot-h) then
                    if ($?DRY_RUN) then
                        echo "DRY: ${IVI_MKDIR} Include_lines"
                        echo "DRY: ${IVI_TOUCH_1990} Makefile-depend-incl-dot-h"
                    else
                        ${IVI_MKDIR} Include_lines
                        if (${status}) then
                            # If this fails, retrying likely will not help. 
                            set exit_status = 1
                            ${P_STDERR} "${IVI_MKDIR} Include_lines failed."
                            break 
                        endif

                        ${IVI_TOUCH_1990} Makefile-depend-incl-dot-h
                        if (${status}) then
                            # If this fails, retrying likely will not help. 
                            set exit_status = 1
                            ${P_STDERR} "Touching Include_lines/Makefile-depend-incl-dot-h in the past failed."
                            break 
                        endif
                    endif 
                endif
            endif 
        endif 
    endif 

    # If need_depend is set to true (usually the case) we build each of the depend
    # targets listed in temp_depend_targets below. But if the target specified is
    # actually one of these, then we build all the ones up to that target. 
    #
    if (( ! $?IVI_SKIP_DEPEND) && (${need_depend}) ) then
        set ivi_depend_make = "${IVI_MAKE} ${IVI_MAKE_OPTS_STOP}"

        # If we are in a library directory, we need to upate Makefile-library
        # because it is included before it is updated (in gmake).  

        if (-e "Makefile-include") then
            if (-e "Makefile-library") then
                set library_makefile_too_old = `${MAKE_SCRIPT_PATH}test_older_than Makefile-library ${MAKE_PATH}Makefile-library`

                if (${library_makefile_too_old}) then
                    ${VERBOSE_ECHO} ""
                    ${VERBOSE_ECHO} "Script build-2 is removing ${cwd}/Makefile-library to force rebuild before include."

                    ${IVI_RM} Makefile-library

                    if (${status}) then
                        # If this fails, retrying likely will not help. 
                        set exit_status = 1
                        ${P_STDERR} "Removal of ${cwd}/Makefile-library in build-2 failed." 
                        break 
                    endif
                endif
            endif
        endif

        # We build 'Makefile' multiple times to force included Makefiles that do not
        # exist to be built. While they often can be built automatically, some would
        # require further restructuring of the code. Currently, for example, if you
        # do a 'make depend_very_clean' in some directory, and change to another
        # program directory (or IVI or IVI_cpp), then the build can be broken due
        # to the library makefiles being removed, but Makefile-dirs still being what
        # it should be.

        # This could be rolled up into a loop, but the error messages would not be
        # as informative.

        ${VERBOSE_ECHO} ""
        ${VERBOSE_ECHO} ==================================================================================
        ${VERBOSE_ECHO} "Script build-2 is using Makefile-2 to build Makefile in ${cwd}."
        ${VERBOSE_ECHO} "This forces the building of included Makefiles (in gmake). "
        ${VERBOSE_ECHO} "We do this multiple times if there are errors."
        ${VERBOSE_ECHO} ""

        if ($?LOG_MAKE) set make_log_file = "${MAKE_LOG_PATH}make_Makefile_${try_count}_1.res"
        ${ivi_depend_make} -f Makefile-2 Makefile |& ${IVI_TEE} ${make_log_file}
        if (${status}) then
            ${P_STDERR} "Initial build of 'Makefile' failed in ${cwd}, but that is OK, it might just mean that we are missing some makefiles."

            if ($?LOG_MAKE) set make_log_file = "${MAKE_LOG_PATH}make_Makefile_${try_count}_2.res"
            ${ivi_depend_make} -f Makefile-2 Makefile |& ${IVI_TEE} ${make_log_file}
            if (${status}) then
                ${P_STDERR} "Second build of 'Makefile' failed in ${cwd}, but often it needs to be done three times. " 

                if ($?LOG_MAKE) set make_log_file = "${MAKE_LOG_PATH}make_Makefile_${try_count}_3.res"
                ${ivi_depend_make} -f Makefile-2 Makefile |& ${IVI_TEE} ${make_log_file}
                if (${status}) then
                    ${P_STDERR} "Third build of 'Makefile' failed in ${cwd}. Trying one more time." 

                    if ($?LOG_MAKE) set make_log_file = "${MAKE_LOG_PATH}make_Makefile_${try_count}_4.res"
                    ${ivi_depend_make} -f Makefile-2 Makefile |& ${IVI_TEE} ${make_log_file}
                    if (${status}) then
                        ${P_STDERR} "Fourth build of 'Makefile' failed in ${cwd}. Cleaning up makefiles." 
                        set makefiles_are_ok = 0
                        goto next_try
                    endif 
                endif
            endif
        endif

        set non_depend_adjusted_args = ""
        foreach arg (${adjusted_args}) 
            # set temp_depend_targets = "Include_lines/file_list.new Include_lines/include_lines.new Include_lines/sub_libs_needed depend"
            # set temp_depend_targets = "file_list.new include_lines.new sub_libs_needed depend"
            #
            # The target "depend_again" is a self-documenting way to do "depend" a
            # second time. We duplicate the target "depend" because in a few cases,
            # the first build of Makefile-depend creates dependencies for itself via
            # the variable DEPEND_DEPENDENCIES.
            #
            set temp_depend_targets = "file_list.new include_lines.new depend depend_again"

            # If we ask for one of the targets listed above, we interpret that as
            # building only the depends, and only up to the target asked for. 
            #
            set depend_targets = ""

            set is_depend_target = 0 

            foreach temp_depend_target (${temp_depend_targets})
                set depend_targets = "${depend_targets} ${temp_depend_target}"

                if ("${arg}" == "${temp_depend_target}") then
                    set is_depend_target = 1
                    break
                endif 
            end

            if (! ${is_depend_target}) then
                set non_depend_adjusted_args = "${non_depend_adjusted_args} ${arg}"
            endif 

            # echo depend_targets: $depend_targets

            set ivi_depend_make = "${IVI_MAKE} ${IVI_MAKE_OPTS_STOP}"
        end
            
        foreach depend_target (${depend_targets})
            if ($?IVI_VERBOSE) then
                ${VERBOSE_ECHO} " "
                ${VERBOSE_ECHO} ==================================================================================
                ${VERBOSE_ECHO} "Script build-2 is building depend target: ${depend_target} in directory ${cwd}."
                ${VERBOSE_ECHO} "Make command is: ${ivi_depend_make} -f Makefile-2 ${depend_target} "
                ${VERBOSE_ECHO} " "
                set sub_start_time = `${IVI_ECHO_TIME}`
            endif 

            if ($?DRY_RUN) then
                echo "DRY: ${ivi_depend_make} -f Makefile-2 ${depend_target} |& ${suppress_jobserver_msg}"
            else
                if ($?LOG_MAKE) set make_log_file = "${MAKE_LOG_PATH}make_${depend_target}_${try_count}.res"
                ${ivi_depend_make} -f Makefile-2 ${depend_target} |& ${suppress_jobserver_msg} |& ${IVI_TEE} ${make_log_file}

                if ($status) then 
                    ${P_STDERR} "Failed to make target ${depend_target} in ${cwd}."
                    set makefiles_are_ok = 0
                    break
                else if ($?IVI_VERBOSE) then
                    set sub_end_time = `${IVI_ECHO_TIME}`
                    ${VERBOSE_ECHO} " "
                    ${VERBOSE_ECHO} "Script build-2 successfully built depend target: ${depend_target} in ${cwd}."
                    ${VERBOSE_ECHO} "Make command was: ${ivi_depend_make} -f Makefile-2 ${depend_target} "
                    ${VERBOSE_ECHO} "    Start time for ${depend_target}: ${sub_start_time}"
                    ${VERBOSE_ECHO} "    End   time for ${depend_target}: ${sub_end_time}"
                endif 
            endif 
        end

        if (! ${makefiles_are_ok}) goto next_try
    else 
        set non_depend_adjusted_args = "${adjusted_args}" 
    endif 

    if ("${non_depend_adjusted_args}" != "") then 
        ${VERBOSE_ECHO} "Script build-2 args continuing with non_depend_adjusted_targets: ${non_depend_adjusted_args}"
    else 
        ${VERBOSE_ECHO} "Script build-2 is done processing targets."
        break
    endif

    foreach arg (${non_depend_adjusted_args}) 
        set make_status = 0
        set force_prod_bin = 0
        set makefile_to_use = "Makefile-2"
        ${IVI_RM} ${make_result_temp_file}

        if (("${arg}" == "all") || ("${arg}" == "code")) then
            # We should revisit building "dir_made", but certainly we only need it
            # if we are building IVI code, so we need to able to skip doing it. 
            #
            if ((${is_parallel}) && (! $?IVI_SKIP_DIR_MADE)) then
                ${VERBOSE_ECHO} " "
                ${VERBOSE_ECHO} "Script build-2 is building dir_made in ${cwd} due to parallel make." 

                if ($?DRY_RUN) then
                    echo "DRY: ${IVI_MAKE_SERIAL} -f Makefile-2 dir_made"
                else
                    if ($?LOG_MAKE) set make_log_file = "${MAKE_LOG_PATH}make_dir_made_${try_count}.res"
                    ${IVI_MAKE_SERIAL} -f Makefile-2 dir_made |& ${suppress_jobserver_msg} |& ${IVI_TEE} ${make_result_temp_file} |& ${IVI_TEE} ${make_log_file}
                    set make_status = ${status}

                    if (${make_status}) then 
                        ${P_STDERR} "Failed to make target 'dir_made' in ${cwd}"
                    endif
                endif 
            endif
        else if (("${arg}" == "doc") || ("${arg}" == "doc_program") || ("${arg}" == "make_bin_aux")) then
            # This could be cleaned up now that we have gone to using BUILD_BIN_PATH
            # instead of make_bin and friends.
            #
            pushd ${MAKE_PATH} > /dev/null
                pushd util > /dev/null
                    pushd c2man-2.40-kobus > /dev/null
                        if ($?IVI_VERBOSE) then
                            echo " "
                            echo "Script build-2 is building utilities in ${cwd}." 
                        endif 
                         
                        if ($?DRY_RUN) then
                            echo "DRY: (setenv IVI_CC ""; setenv PRODUCTION 1; setenv BUILD_BIN_PATH "${MAKE_BIN_PATH}"; source ${MAKE_PATH}init_compile; ${IVI_MAKE_SERIAL} bin |& ${suppress_jobserver_msg})"
                        else
                            # We only want to make the documentation tools using the default C
                            # compiler and production mode. The setting of IVI_CC to empty asks
                            # init_compile to choose the compiler. 
                            #
                            if ($?LOG_MAKE) set make_log_file = "${MAKE_LOG_PATH}make_c2man_bin_${try_count}.res"
                            (setenv IVI_CC ""; setenv PRODUCTION 1; setenv BUILD_BIN_PATH "${MAKE_BIN_PATH}"; source ${MAKE_PATH}init_compile; ${IVI_MAKE_SERIAL} bin |& ${suppress_jobserver_msg} |& ${IVI_TEE} ${make_result_temp_file} |& ${IVI_TEE} ${make_log_file}) 
                            set make_status = ${status}

                            if (${make_status}) then 
                                ${P_STDERR} "Failed to make target 'make_bin' in ${cwd}"
                            endif 
                        endif 
                    popd > /dev/null

                    if (! ${make_status}) then
                        ${VERBOSE_ECHO} " "
                        ${VERBOSE_ECHO} "Script build-2 is building utilities in ${cwd}." 

                        if ($?DRY_RUN) then
                            echo "DRY: (setenv IVI_CC ""; setenv PRODUCTION 1; setenv BUILD_BIN_PATH "${MAKE_BIN_PATH}"; source ${MAKE_PATH}init_compile; ${IVI_MAKE_SERIAL} bin |& ${suppress_jobserver_msg} )"
                        else
                            # We only want to make the documentation tools using the default C
                            # compiler and production mode. The setting of IVI_CC to empty asks
                            # init_compile to choose the compiler. 
                            #
                            if ($?LOG_MAKE) set make_log_file = "${MAKE_LOG_PATH}make_util_bin_${try_count}.res"
                            (setenv IVI_CC ""; setenv PRODUCTION 1; setenv BUILD_BIN_PATH "${MAKE_BIN_PATH}"; source ${MAKE_PATH}init_compile; ${IVI_MAKE_SERIAL} bin |& ${suppress_jobserver_msg} |& ${IVI_TEE} ${make_result_temp_file} |& ${IVI_TEE} ${make_log_file} ) 
                            set make_status = ${status}

                            if (${make_status}) then 
                                ${P_STDERR} "Failed to make target 'make_bin' in ${cwd}"
                            endif 
                        endif 
                    endif 
                popd > /dev/null
            popd > /dev/null

            if ("${arg}" == "make_bin_aux") continue

            if (${is_parallel}) then
                if ($?IVI_VERBOSE) then
                    echo "Script build-2 is building doc_dir_made in ${cwd} due to parallel make." 
                endif 

                if ($?DRY_RUN) then
                    echo "DRY: ${IVI_MAKE_SERIAL} -f Makefile-2 doc_dir_made |& ${suppress_jobserver_msg}"
                else
                    if ($?LOG_MAKE) set make_log_file = "${MAKE_LOG_PATH}make_doc_dir_made_${try_count}.res"
                    ${IVI_MAKE_SERIAL} -f Makefile-2 doc_dir_made |& ${suppress_jobserver_msg} |& ${IVI_TEE} ${make_result_temp_file} |& ${IVI_TEE} ${make_log_file}
                    set make_status = ${status}

                    if (${make_status}) then 
                        ${P_STDERR} "Failed to make target doc_dir_made in ${cwd}"
                    endif 
                endif 
            endif 
        else if (("${arg}" == "bin") || ("${arg}" == "load") || ("${arg}" == "misc_load")) then
            # init_compile ensures PRODUCTION is either 0 or 1
            if (! $PRODUCTION) then
                set force_prod_bin = 1
                if ($?DONT_FORCE_PROD_BIN) then
                    if ($DONT_FORCE_PROD_BIN) then
                        set force_prod_bin = 0
                    endif 
                endif 

                if (${force_prod_bin}) then
                    ${VERBOSE_ECHO} " "
                    ${VERBOSE_ECHO} "Script build-2 using production mode for ${arg}"
                    ${VERBOSE_ECHO} "To disable this default behaviour, use 'setenv DONT_FORCE_PROD_BIN 1'."
                    ${VERBOSE_ECHO} " "

                    if ($?DRY_RUN) then
                        echo "DRY: setenv PRODUCTION 1"
                        echo "DRY: source ${MAKE_PATH}init_compile"
                    else
                        setenv PRODUCTION 1
                        set save_default_make = "${IVI_MAKE}"
                        source ${MAKE_PATH}init_compile
                        set make_status = ${status}
                        setenv IVI_MAKE "${save_default_make}"
                    endif 

                    ${VERBOSE_ECHO} " "
                endif 
            endif 
        else 
            # If we are testing a particular program (not necessarily all that is in
            # a directory) then arg will have been switched to the more specific
            # target as arranged above. 
            #
            set prog = ""
            if (("${arg}" == "test") || ("${arg}" == "regress")) then
                set test_arg = 1
                set prog = "all"
            else if ( ("${arg}" == "check")  || ("${arg}" == "test_svn") )  then
                set test_arg = 1
            else if (("${arg}" == "test_clean") || ("${arg}" == "test_very_clean") || ("${arg}" == "regress_clean")  || ("${arg}" == "test_invalid") )  then
                set test_arg = 1
            else 
                set test_arg = `echo ${arg} | grep -c '/output_checked$'`
                if (${test_arg}) then
                    set prog =  `echo ${arg} | sed 's#test_runs//*\([^/]*\).*#\1#'`
                    set prog = "${LD_OBJ_DIR}${prog}"
                else 
                    set test_arg = `echo ${arg} | grep -c '/regression_test_passed$'`

                    if (${test_arg}) then
                        set prog =  `echo ${arg} | sed 's#test_runs//*\([^/]*\).*#\1#'`
                        set prog = "${LD_OBJ_DIR}${prog}"
                    else 
                        set test_arg = `echo ${arg} | grep -c '/svn_phony$'`
                    endif 
                endif 
            endif 

            if (! ${test_arg}) then
                foreach test_target_suffix (${test_target_suffixes})
                    set test_arg = `echo ${arg} | grep -c "\.${test_target_suffix}${dollar}"`
                    if (${test_arg}) then 
                        ${VERBOSE_ECHO} "Target $arg matches test target suffix '$test_target_suffix'"
                        break
                    endif
                end
            endif 

            if (${test_arg}) then
    #           # All this stuff from before should not be necessary. Kill it
    #           eventually. Claim made 12/13/2019.
    #
    #             if (! -e "Makefile-test-depend") then
    #                 set make_tmp_dir = "${TMPDIR}/${USER}/Makefile-test-depend/make"
    #                 ${IVI_MKDIR} "${make_tmp_dir}"
    #                 if (${status}) then
    #                     ${P_STDERR} "Unable to make directory ${make_tmp_dir}"
    #                     exit 1
    #                 endif 
    #                 ${MAKE_SCRIPT_PATH}build_test_depend > ${make_tmp_dir}/Makefile-test-depend
    #                 if (${status}) then
    #                     ${P_STDERR} "Unable to build Makefile-test-depend."
    #                     exit 1
    #                 else 
    #                     ${IVI_CP} ${make_tmp_dir}/Makefile-test-depend .
    #                     if (${status}) then
    #                         ${P_STDERR} "Unable to copy ${make_tmp_dir}/Makefile-test-depend to `pwd`."
    #                         exit 1
    #                     endif 
    #                 endif 
    #             endif 

                if ("${prog}" != "") then
                    if ($?IVI_VERBOSE) then
                        echo " "
                        echo "Script build-2 is checking whether target ${prog} is up to date, using: "
                        echo "    ${IVI_MAKE} -q ${prog} -f Makefile-2  "
                    endif 

                    # Not all makes necessarily have '-q', but then, they might have '-n'
                    # whose output we can grep. Currently, we only use gmake. The
                    # consequence of not being able to check in advance if things are up
                    # to date is to simply do extra processing, so if the script breaks
                    # here, and the version of make cannot be made to confess, then
                    # skipping this part is fine.

                    ${IVI_MAKE} -q ${prog} -f Makefile-2 |& ${suppress_jobserver_msg}
                    if (! ${status}) then
                        if ( ! $?IVI_QUIET ) then
                            echo "Script build-2 reports target [ ${prog} ] is up to date."
                        endif 
                    else 
                        if ($?DRY_RUN) then
                            echo "DRY: ${IVI_MAKE} -f Makefile-2 ${prog} |& ${suppress_jobserver_msg}"
                        else
                            if ($?LOG_MAKE) set make_log_file = "${MAKE_LOG_PATH}make_prog_${try_count}.res"
                            ${IVI_MAKE} -f Makefile-2 ${prog} |& ${suppress_jobserver_msg} |& ${IVI_TEE} ${make_result_temp_file} |& ${IVI_TEE} ${make_log_file}
                            set make_status = ${status}

                            if (${make_status}) then 
                                ${P_STDERR} " "
                                ${P_STDERR} "Build of ${prog} failed."
                                ${P_STDERR} " "
                            endif 
                        endif 
                    endif 
                endif 

                set makefile_to_use = "${MAKE_PATH}Makefile-test"

    #           # All this stuff from before should not be necessary. Kill it
    #           eventually. Claim made 12/13/2019.
    #
    #             # We may need to build Makefile-test-depend twice.
    #             foreach target ( Makefile-test-depend  Makefile-test-depend)
    #                 if ($?IVI_VERBOSE) then
    #                     echo " "
    #                     echo "Script build-2 is checking whether target ${target} is up to date."
    #                 endif 
    # 
    #                 # Not all makes necessarily have '-q', but then, they might have '-n'
    #                 # whose output we can grep. Currently, we only use gmake. The
    #                 # consequence of this failing is simply to run make for real.
    # 
    #                 ${IVI_MAKE} -q ${target} -f ${makefile_to_use} |& ${suppress_jobserver_msg}
    #                 if (! ${status}) then
    #                     if ( ! $?IVI_QUIET ) then
    #                         echo "Script build-2 reports target [ ${target} ] is up to date."
    #                     endif 
    #                 else 
    #                     set make_command = "${IVI_MAKE} ${target} -f ${makefile_to_use}"
    # 
    #                     if ($?IVI_VERBOSE) then
    #                         echo " "
    #                         echo "Script build-2 is building target: ${target} in directory ${cwd}."
    #                         echo "Make command is: ${make_command}"
    #                         echo " "
    #                     endif 
    # 
    #                     ${make_command} |& ${suppress_jobserver_msg}
    # 
    #                     if ($status) then
    #                         ${P_STDERR} "Failed to make target(s) ${target} in ${cwd}"
    #                         exit 1
    #                     endif 
    #                 endif 
    #             end

            endif 
        endif 

        # This completes preparatory building for a our target "arg". If it has
        # been successful so far, build "arg".

        if (! ${make_status}) then
            if ($?IVI_VERBOSE) then
                ${VERBOSE_ECHO} " "
                ${VERBOSE_ECHO} ==================================================================================
                ${VERBOSE_ECHO} "Script build-2 is building target: ${arg} in directory ${cwd}."
                ${VERBOSE_ECHO} "Make command is: ${IVI_MAKE} -f ${makefile_to_use} ${arg}"
                ${VERBOSE_ECHO} " "
                set sub_start_time = `${IVI_ECHO_TIME}`
            endif 

            if ($?DRY_RUN) then
                echo "DRY: ${IVI_MAKE} -f ${makefile_to_use} ${arg} |& ${suppress_jobserver_msg}"
            else
                if ($?LOG_MAKE) set make_log_file = "${MAKE_LOG_PATH}make_${arg}_${try_count}.res"
                ${IVI_MAKE} -f ${makefile_to_use} ${arg} |& ${suppress_jobserver_msg} |& ${IVI_TEE} ${make_result_temp_file} |& ${IVI_TEE} ${make_log_file}
                set make_status = ${status}

                if (${make_status}) then
                    ${P_STDERR} "Failed to make target(s) ${arg} in ${cwd}."
                endif 
           endif 
        endif 

        if (${make_status}) then
            if (-e "${make_result_temp_file}") then
                set build_issue = `${IVI_GREP} -c 'No rule to make target' < "${make_result_temp_file}"`

                if (${build_issue}) then
                    ${P_STDERR} "This appears to be a makefile issue."
                    set makefiles_are_ok = 0
                else 
                    set exit_status = 1
                endif 
            else 
                set exit_status = 1
            endif 

            break
        else if ($?IVI_VERBOSE) then
            set sub_end_time = `${IVI_ECHO_TIME}`
            echo " "
            echo "Script build-2 successfully built target: ${arg} in directory ${cwd}."
            echo "Make command was: ${IVI_MAKE} -f ${makefile_to_use} ${arg}"
            echo "    Start time for ${arg}: ${sub_start_time}"
            echo "    End   time for ${arg}: ${sub_end_time}"
        endif 

        if (${force_prod_bin}) then
            # Set it back to dev mode. We would only have set force_prod_bin if we
            # were in dev mode at the start of the loop. 
            ${VERBOSE_ECHO} "Script build-2 resetting development mode after processing ${arg}"

            if ($?DRY_RUN) then
                echo "DRY: setenv PRODUCTION 0"
                echo "DRY: source ${MAKE_PATH}init_compile"
            else
                setenv PRODUCTION 0
                source ${MAKE_PATH}init_compile
                set exit_status = ${status}
            endif 
        endif 
    end

    # We only try multiple times to build makefiles, not code. 
    if (${makefiles_are_ok}) break

    next_try:

    ${P_STDERR} " "
    ${P_STDERR} "There is an issues with at least one makefile or build script."

    if ($?SKIP_DEPEND_RETRY) then
        ${P_STDERR} "Skipping retry of building makefiles, as SKIP_DEPEND_RETRY is set."
        ${P_STDERR} "Perhaps a 'make depend_clean' is needed, and/or cache cleaning."
        ${P_STDERR} " "
        set exit_status = 1
        break
    else if (${try_count} == 4) then
        ${P_STDERR} "Fourth (fresh and serial) try at building makefiles failed. Giving up."
        set exit_status = 1
        break
    else 
        if (${try_count} == 1) then
            ${WARN_ECHO} "Trying to build a second time with rebuild of local makefiles."
            ${WARN_ECHO} "Disable with: setenv SKIP_DEPEND_RETRY"
        else if (${try_count} == 2) then
            ${WARN_ECHO} "Forcing rebuild of build files, and trying again."
            ${WARN_ECHO} "Disable with: setenv SKIP_DEPEND_RETRY"
        else
            ${WARN_ECHO} "Forcing rebuild of build files, and trying yet again without locking and building serially."
            ${WARN_ECHO} "Disable with: setenv SKIP_DEPEND_RETRY"
            setenv BUILD_SUB_LIBS_SERIAL
            setenv BUILD_FILE_LISTS_SERIAL
            setenv IVI_MAKE "${IVI_MAKE_SERIAL}"
            setenv DONT_LOCK
        endif 

        source ${MAKE_SCRIPT_PATH}clean_cache
        source ${MAKE_SCRIPT_PATH}clean_locks

        if (${try_count} == 1) then
            source ${MAKE_SCRIPT_PATH}clean_local
        else
            source ${MAKE_SCRIPT_PATH}clean_global
        endif 
    endif 

    @ try_count ++
end

if (! ${exit_status}) then
    if ( ! $?IVI_QUIET ) then
        if ( ! $?SKIP_SVN_MESSAGES ) then
            $VERBOSE_ECHO "Checking for pending SVN commits."
            svn info >& /dev/null
            if (! $status) then 
                set have_changes = `svn status | grep -v -c '^?'`
                if ($have_changes) then
                    echo " "
                    echo "Pending SVN commits: " 
                    svn status | grep -v '^?' | sed 's/^/    /'
                endif 
            endif 

            $VERBOSE_ECHO "Done checking for pending SVN commits."
        endif 
    endif 
endif 

end_of_script: 

${IVI_RM} ${make_result_temp_file}

if ( ! $?IVI_QUIET ) then
    set end_time = `${IVI_ECHO_TIME}`
    echo " "
    echo "Build for adjusted targets [ ${adjusted_args} ] completed at ${end_time} with status ${exit_status}"
    echo "Build for adjusted targets [ ${adjusted_args} ] started at   ${start_time}"
    echo " "

endif 

exit ${exit_status}

