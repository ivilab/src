#!/bin/tcsh -f 

##############################################################################
#
# Identification:
#     Creates a semaphore that blocks cooperating processes from proceeding 
#     until removed (using ivi_lock_remove).
#
# Description:
#     This is a simple script for locking blocks of script code that is not
#     conveniently expressed as a command (otherwise use ivi_lock). It works
#     much like lockfile-create, and in fact, is implemented using
#     lockfile-create if it is available. The main justification for this script
#     is that locking is not universally available. Most notably good locking
#     facilities are not available in the mac OS. Hence, this script also
#     implements a fall back method that is less than ideal, but usually works. 
#
#     The first argument to ivi_lock_create is the max number of seconds to wait. This
#     is to be consistent with ivi_lock.
#
#     The second argument to ivi_lock_create is simply a label (often just the
#     name of the script), which is combined with the current directory to
#     create a lockfile name. At the end of the protected code, you must call
#     ivi_lock_remove with the second and third arguments. 
#
#     The third (optional argument) is the PID of the script interested in the
#     lock. It defaults to the PID of the process that called it (this script's
#     parent process). 
#
#     If the environment variable IVI_LOCK_PROGS_METHOD is set, this script will
#     use its value for the locking method. 
#
#     If the environment variable IVI_LOCKFILE_PATH is set, this script will use
#     its value as a directory to create lockfiles in. Otherwise, this script
#     will first try /scratch/${USER}/lockfiles/ unless PREFER_LOCAL_LOCK is
#     set, where /scratch is nominally an NSF mounted fast temporary disk on
#     IVILAB systems. If it does not exist, or PREFER_LOCAL_LOCK is set, then we 
#     use ${TMPDIR}/${USER}/lockfiles/. In all cases we attempt to create the
#     $IVI_LOCKFILE_PATH path if it does not exist, and exit with 1 if we
#     cannot. 
#
#     if the environment variable IVI_LOCKFILE_NAME is set, then it overrides
#     the default heuristics for constructing the lock file name. If
#     IVI_LOCKFILE_NAME looks like a path it is used as is. Otherwise, we append
#     the string ".lock" to $IVI_LOCKFILE_NAME, and use that for a lockfile in
#     the lockfile directory.
#
#     Finally, if the environment variable IVI_DONT_LOCK is set, then this
#     script essentially does nothing. The main purpose of this is to avoid
#     deadlock when we effectively call scripts recursively. Normally there is a
#     better way to accomplish what you want to do.
#
# Deficiencies
#     The current implementation locks all runs of a command operating in a
#     given sub-directory, which is is not a big issue as it is simply overly
#     conservative. If this becomes an issue, we can put more path components in
#     the lockfile name. 
#
# Author:
#     Kobus Barnard 
#
##############################################################################

# We assume that init_scripts has been called as this script is largely used as
# part of the IVI build system reflected by the fact that it lives in Make.
# Thus, we have P_STDERR, VERBOSE_ECHO, and MAKE_SCRIPT_PATH. 

# This script must be kept in sync with ivi_lock_remove

if ($?IVI_SET_ECHO) then
    set echo
endif 

${VERBOSE_ECHO} "${VERBOSE_INDENT}Script ivi_lock_create process $$ called with args: $*."

if ($# < 2) then
    ${P_STDERR} "Script ivi_lock_create needs at least two arguments."
    exit 1
else if ($# < 3) then
    set requesting_pid = `ps -p $$ -o ppid=`
else 
    set requesting_pid = $3 
endif 

set max_time_to_wait = "$1"
if ("${max_time_to_wait}" == "") then
    ${P_STDERR} "Script ivi_lock_create received a null first argument."
    exit 1 
endif 

set check_time_arg = `echo "${max_time_to_wait}" | sed 's/[0-9]//g'`
if ("${check_time_arg}" != "") then
    ${P_STDERR} "Script ivi_lock_create first arg (${max_time_to_wait}) must be a non-negative integer."
    exit 1 
endif 

if ($?IVI_DONT_LOCK) then
    # If no lock, then we bail, but purposefully, after checking arguments.
    ${VERBOSE_ECHO} "${VERBOSE_INDENT}IVI_DONT_LOCK is set, so ivi_lock_create is not doing anything"
    exit 0
endif

# We work in units of 0.01s. 
@ max_time_to_wait *= 100

set lock_label = "$2"

set exit_status = 0

set noclober

source ${MAKE_SCRIPT_PATH}set_lockfile_name
if (${status}) exit ${status} 

onintr ivi_lock_create_bail

${VERBOSE_ECHO} "${VERBOSE_INDENT}Script ivi_lock_create process $$ running lock_create ${lock_label} in ${cwd}"
${VERBOSE_ECHO} "${VERBOSE_INDENT}    on behalf of process ${requesting_pid} using lockfile '${lock_file}'"

if ("${IVI_LOCK_PROGS_METHOD}" == "lockfile-progs") then
    echo "UNTESTED: Process $$ running lock_create ${lock_label} in `pwd` using lockfile-progs"

    # lockfile-create has its own timeout formula which defaults to 3 minutes.
    # We may need to wrap it in a loop. 
    echo "IGNORING timeout due to using lockfile-progs locking method."

    lockfile-create --lock-name argument ${lock_file}

    if (! ${status}) then
        ${VERBOSE_ECHO} "${VERBOSE_INDENT}Process $$ successfully set ${lock_label} in `pwd` using lockfile-create."
    endif
else 
    # IVI locking method. Doing locking robustly in scripts is hard, but
    # often (e.g., mac) we do not have a good solution. The following is better
    # than nothing.

    ${VERBOSE_ECHO} "${VERBOSE_INDENT}Process $$ running lock_create ${lock_label} in `pwd` using IVI locking system."

    set start_time = `date +%H:%M:%S`

    # Reduce the chances of everyone wanting to start at the same time.
    # I do not know how likely this is to fail, or even to return success
    # without doing the right thing, but it seems to work on the mac. 

    set x = $$ ; @ x %= 100 ; set sleep_time = "0.0${x}"
    ${VERBOSE_ECHO} "${VERBOSE_INDENT}Process $$ sleeping for ${sleep_time} seconds"
    sleep ${sleep_time}

    if (${status}) then
        ${P_STDERR} "Fractional sleep failed in ivi_lock_create." 
        set exit_status = 1
        goto cleanup
    endif

    set time_waited = 0

    while (1) 
        if (! -e "${lock_file}") then
            # Unlike some of the similar lines below, we do not have an '!'
            # after the '>', as we want to fail due to noclober.
            #
            echo ${requesting_pid} > ${lock_file}

            # Someone else might have just written the file. 
            if (${status}) then
                #  I have not found a safe way to ignore error output. 
                set apparent_lock_owner = `cat ${lock_file}`
                if (${status}) then
                    echo "Someone might have snuck in before me (${requesting_pid}). Sleeping."
                else
                    echo "Process ${apparent_lock_owner} snuck in before me (${requesting_pid}). Sleeping."
                endif 

                set x = ${requesting_pid} ; @ x %= 100 ; set sleep_time = "0.${x}"

                @ time_waited += $x

                ${VERBOSE_ECHO} "${VERBOSE_INDENT}Process $$ sleeping for ${sleep_time} seconds for ${requesting_pid}."

                sleep ${sleep_time}

                if (${status}) then
                    ${P_STDERR} "Fractional sleep failed in ivi_lock_create." 
                    set exit_status = 1
                    goto cleanup
                endif

                continue
            endif 

            ${VERBOSE_ECHO} "${VERBOSE_INDENT}Process $$ tentatively set lock file ${lock_file} for ${requesting_pid}."
            # ps -l $$
        else 
            set count = 0
            set got_it = 0

            while (-e "${lock_file}")
                #  I have not found a safe way to ignore error output. 
                set lock_proc = `cat ${lock_file}`

                # Happens! 
                if ($status) then 
                    echo ${requesting_pid} >! ${lock_file}
                    echo "Lock file ${lock_file} disappeared! Taking the lock."
                    set got_it = 1
                    break
                endif 

                # If the contents is bogus, then the ps below will fail. But if
                # it is empty, ps will not fail. So we check here. 
                #
                if ("${lock_proc}" == "") then
                    echo ${requesting_pid} >! ${lock_file}
                    echo "Cannot read a process id from lock file. Assuming it is stale."
                    set got_it = 1
                    break
                endif 

                ${VERBOSE_ECHO_2} "${VERBOSE_INDENT}Lock file ${lock_file} exists."

                # Check up on the process holding the lock every so often. We
                # used to do it every time through the loop, but we then
                # expected that this lead to spending too much time in the 'ps'
                # caommand. However, it turned out that the issue was from
                # build_sub_libs_needed, but it seems that this is a good
                # optimization for some circumstances anyway. 
                
                @ block_cycle = ${count} % 10

                if (${block_cycle} == 0) then
                    ${VERBOSE_ECHO_2} "${VERBOSE_INDENT}Process $$ checking on lock file process ${lock_proc} on iteration ${count}." 

                    ps ${lock_proc} >& /dev/null
                    set ps_status = "${status}" 

                    if (${ps_status}) then
                        echo ${requesting_pid} >! ${lock_file}

                        ${VERBOSE_ECHO} "${VERBOSE_INDENT}Process $$ resetting lock file ${lock_file} for process ${requesting_pid} as process ${lock_proc} does not exist."

                        set got_it = 1
                        break
                    # else if (${count} > ${lock_wait_iterations}) then
                    else if (${time_waited} > ${max_time_to_wait}) then
                        echo "Process $$ waited too long for ${lock_file} on behalf of process ${requesting_pid}. "
                        echo "Process $$ waited for ${time_waited} X 0.01 seconds, exceeding the limit of ${max_time_to_wait} X 0.01 seconds."
                        set end_time = `date +%H:%M:%S`
                        echo "Specifically it waited from ${start_time} to ${end_time}." 
                        echo "Information about the process (${lock_proc}) holding the lock:"
                        ps -l ${lock_proc} 
                        echo "Information about the process (${requesting_pid}) requesting the lock:"
                        ps -l ${requesting_pid} 

                        if ($?EXIT_ON_LOCK_TIMEOUT) then
                            echo "Process $$ waiting for ${lock_file} exiting with failure because EXIT_ON_LOCK_TIMEOUT is set." 
                            set exit_status = 1
                            goto cleanup
                        endif 

                        echo "Sleeping for 5 seconds for debugging" 
                        sleep 5
                        echo "Ignoring the lock."
                        echo ${requesting_pid} >! ${lock_file}
                        set got_it = 1
                        break
                    endif
                else
                    ${VERBOSE_ECHO_2} "${VERBOSE_INDENT}Process $$ not checking up on lock file process ${lock_proc} on iteration ${count}." 
                endif 

                ${VERBOSE_ECHO_2} "${VERBOSE_INDENT}Process $$ waiting for ${lock_file} held on behalf of process ${lock_proc}."

                # Add some fractional seconds to reduce the chances of everyone
                # wanting to start at the same time.
                set x = ${requesting_pid} ; @ x %= 100 ; set sleep_time = "0.${x}"

                ${VERBOSE_ECHO_2} "${VERBOSE_INDENT}Process $$ sleeping for ${sleep_time} seconds"
                ${VERBOSE_ECHO_2} "${VERBOSE_INDENT}Process $$ slept ${time_waited}/${max_time_to_wait} x .01 seconds."
                sleep ${sleep_time} >& /dev/null

                @ time_waited += $x

                if (${status}) then
                    ${P_STDERR} "Fractional sleep failed in ivi_lock_create." 
                    set exit_status = 1
                    goto cleanup
                
                endif

                @ count ++
            end

            # If we got_it is still false, then the lock file was removed by the
            # process we were waiting on.
            #
            if (! ${got_it}) then
                echo ${requesting_pid} >! ${lock_file}
                ${VERBOSE_ECHO} "${VERBOSE_INDENT}Process $$ setting lock file ${lock_file} for process ${requesting_pid} as the lock file no longer exists."
            endif 
        endif 

        # Check for clash. I have not found a safe way to ignore error output. 
        set lock_proc = `cat ${lock_file}` 
        if (${status}) then
            # Could happen.
            ${VERBOSE_ECHO} "${VERBOSE_INDENT}Lock file ${lock_file} disappeared. Trying again to get the lock."
        else if (${lock_proc} != ${requesting_pid}) then 
            ${VERBOSE_ECHO} "${VERBOSE_INDENT}Process ${lock_proc} beat us to the lock on ${lock_file}. Resuming waiting."
        else 
            break
        endif 
    end

    ${VERBOSE_ECHO} "${VERBOSE_INDENT}Process $$ set lock with label ${lock_label} for process ${requesting_pid} in `pwd`."
    set end_time = `date +%H:%M:%S`
    ${VERBOSE_ECHO_2} "${VERBOSE_INDENT}Process $$ locking start time: ${start_time}."
    ${VERBOSE_ECHO_2} "${VERBOSE_INDENT}Process $$ locking   end time: ${end_time}."
endif 

cleanup: 
    
# Restore 
onintr
    
exit ${exit_status}

# We should not be here unless onintr

ivi_lock_create_bail:

${VERBOSE_ECHO} "${VERBOSE_INDENT}Process $$ doing ivi_lock_create got an interrupt."

# If we are not locking or even if we are, then the lock_file variable might not
# be set when we got interrupted.

if (${safe_to_lock}) then
    if (${?lock_file}) then 
        if (-e "${lock_file}") then 
            ${P_STDERR} "Script ivi_lock_create process $$ removing lock file ${lock_file} because of interrupt."
            ${P_STDERR} " "
            ${IVI_RM} "${lock_file}"
        endif 
    endif 
endif 

exit 1


   
