#!/bin/tcsh -f 

##############################################################################
#
# Identification:
#     Creates a semaphore that blocks cooperating processes from proceeding 
#     until removed (using ivi_lock_remove).
#
# Description:
#     This is a simple script for locking blocks of script code that is not
#     conveniently expressed as a command (otherwise use ivi_lock). It works
#     much like lockfile-create, and in fact, is might be implemented using
#     lockfile-create if it is available. The main justification for this script
#     is that locking is not universally available. Most notably good locking
#     facilities are not available in the mac OS. Hence, this script also
#     implements a fall back method that is less than ideal, but usually works. 
#
#     The first argument to ivi_lock_create is the max number of seconds to wait. This
#     is to be consistent with ivi_lock.
#
#     The second argument to ivi_lock_create is simply a label (often just the
#     name of the script), which is combined with the current directory to
#     create a lockfile name. At the end of the protected code, you must call
#     ivi_lock_remove with the second and third arguments. 
#
#     The third (optional argument) is the PID of the script interested in the
#     lock. It defaults to the PID of the process that called it (this script's
#     parent process). 
#
#     If the environment variable IVI_LOCK_PROGS_METHOD is set, this script will
#     use its value for the locking method. 
#
#     If the environment variable IVI_LOCKFILE_PATH is set, this script will use
#     its value as a directory to create lockfiles in. Otherwise, this script
#     will first try /scratch/${USER}/lockfiles/ unless PREFER_LOCAL_LOCK is
#     set, where /scratch is nominally an NSF mounted fast temporary disk on
#     IVILAB systems. If it does not exist, or PREFER_LOCAL_LOCK is set, then we 
#     use ${TMPDIR}/${USER}/lockfiles/. In all cases we attempt to create the
#     $IVI_LOCKFILE_PATH path if it does not exist, and exit with 1 if we
#     cannot. 
#
#     if the environment variable IVI_LOCKFILE_NAME is set, then it overrides
#     the default heuristics for constructing the lock file name. If
#     IVI_LOCKFILE_NAME looks like a path it is used as is. Otherwise, we append
#     the string ".lock" to $IVI_LOCKFILE_NAME, and use that for a lockfile in
#     the lockfile directory.
#
#     Finally, if the environment variable IVI_DONT_LOCK is set, then this
#     script essentially does nothing. The main purpose of this is to avoid
#     deadlock when we effectively call scripts recursively. Normally there is a
#     better way to accomplish what you want to do.
#
# Deficiencies
#     The current implementation locks all runs of a command operating in a
#     given sub-directory, which is is not a big issue as it is simply overly
#     conservative. If this becomes an issue, we can put more path components in
#     the lockfile name. 
#
# Author:
#     Kobus Barnard 
#
##############################################################################

# We assume that init_scripts has been called as this script is largely used as
# part of the IVI build system reflected by the fact that it lives in Make.
# Thus, we have P_STDERR, VERBOSE_ECHO, and MAKE_SCRIPT_PATH. 

# This script must be kept in sync with ivi_lock_remove

if ($?IVI_SET_ECHO) then
    set echo
endif 

${VERBOSE_ECHO} "${VERBOSE_INDENT}Script ivi_lock_create called with args: $*."

if ($# < 2) then
    ${P_STDERR} "Script ivi_lock_create needs at least two arguments."
    exit 1
else if ($# < 3) then
    set requesting_pid = `ps -p $$ -o ppid=`
else 
    set requesting_pid = $3 
endif 

set max_time_to_wait = "$1"
if ("${max_time_to_wait}" == "") then
    ${P_STDERR} "Script ivi_lock_create received a null first argument."
    exit 1 
endif 

set check_time_arg = `echo "${max_time_to_wait}" | sed 's/[0-9]//g'`
if ("${check_time_arg}" != "") then
    ${P_STDERR} "Script ivi_lock_create first arg (${max_time_to_wait}) must be a non-negative integer."
    exit 1 
endif 

if ($?IVI_DONT_LOCK) then
    # If no lock, then we bail, but purposefully, after checking arguments.
    ${VERBOSE_ECHO} "${VERBOSE_INDENT}IVI_DONT_LOCK is set, so ivi_lock_create is not doing anything"
    exit 0
endif

# We work in units of .01s. 
@ max_time_to_wait *= 100

set lock_label = "$2"

set exit_status = 0

set noclobber

source ${MAKE_SCRIPT_PATH}set_lockfile_name
if (${status}) exit ${status} 

onintr ivi_lock_create_bail

${VERBOSE_ECHO} "${VERBOSE_INDENT}Script ivi_lock_create using lock file ${lock_file} for ${requesting_pid} in ${cwd}"

if ("${IVI_LOCK_PROGS_METHOD}" == "lockfile-progs") then
    echo "UNTESTED: Process $$ running lock_create ${lock_label} in `pwd` using lockfile-progs"

    # lockfile-create has its own timeout formula which defaults to 3 minutes.
    # We may need to wrap it in a loop. 
    echo "IGNORING timeout due to using lockfile-progs locking method."

    lockfile-create --lock-name argument ${lock_file}

    if (! ${status}) then
        ${VERBOSE_ECHO} "${VERBOSE_INDENT}Process $$ successfully set ${lock_label} in `pwd` using lockfile-create."
    endif
else 
    # IVI locking method. Doing locking robustly in scripts is hard, but
    # often (e.g., mac) we do not have a good solution. The following is better
    # than nothing.

    ${VERBOSE_ECHO} "${VERBOSE_INDENT}Process ${requesting_pid} handler running lock_create ${lock_label} in ${cwd} using IVI locking system."

    set start_time = `date +%H:%M:%S`

    set time_waited = 0

    set got_it = 0

    set zero = ""
    @ x = $$ % 100; @ y = $x % 10;  @ z = $x / 10; @ w = 10 * $y + $z; @ w /= 3
    if ($w < 10) set zero = "0" 
    set sleep_time = "0.${zero}${w}"

    set id = "${requesting_pid}"
    set id = "${SHORT_HOST}-${requesting_pid}"

    while (1) 
        # Reduce the chances of everyone wanting to start at the same time.
        # I do not know how likely this is to fail, or even to return success
        # without doing the right thing, but it seems to work on the mac. 

        ${VERBOSE_ECHO} "${VERBOSE_INDENT}Lock handler for ${id} sleeping for ${sleep_time} seconds"
        sleep ${sleep_time}
        @ time_waited += ${w}

        if (${status}) then
            ${P_STDERR} "Fractional sleep failed in ivi_lock_create." 
            set exit_status = 1
            goto cleanup
        endif

        if (! -e "${lock_file}") then
            ${MAKE_SCRIPT_PATH}atomic_echo ${lock_file} "${id}" 
            set atomic_echo_status =  ${status}

            if (${atomic_echo_status}) then
                ${VERBOSE_ECHO} "${VERBOSE_INDENT}Lock handler for ${requesting_pid} failed to get lock. Geting back in the queue."
                continue
            else 
                ${VERBOSE_ECHO} "${VERBOSE_INDENT}Process ${requesting_pid} lock handler has set lock file ${lock_file} (contents `cat ${lock_file}`)."
                set got_it = 1
            endif
        else 
            set count = 0

            while (-e "${lock_file}")
                # Check up on the process holding the lock every so often. We
                # used to do it every time through the loop, but we then
                # expected that this lead to spending too much time in the 'ps'
                # caommand. However, it turned out that the issue was from
                # build_sub_libs_needed, but it seems that this is a good
                # optimization for some circumstances anyway. 
               
                @ block_cycle = ${count} % 5
                @ block_cycle = ${count} % 1

                if (${block_cycle} == 0) then
                    #  I have not found a safe way to ignore error output. 
                    set lock_id = `cat ${lock_file}`
                    set cat_status = ${status}

                    if (${cat_status}) then 
                        # Happens! But just grabbing the lock is not safe. 
                        ${VERBOSE_ECHO} "${VERBOSE_INDENT}Lock file ${lock_file} disappeared! Getting back in the queue."
                        continue
                    else
                        set lock_proc = `echo ${lock_id} | ${IVI_SED} 's/^.*-//'`
                        if (${status}) then 
                            ${WRN_ECHO} "Script ivi_lock_remove sed command failed. This should never happen."
                        endif 
                    endif 

                    set remove_lock_file = 0

                    # If the contents is bogus, then the ps below will fail. But if
                    # it is empty, ps will not fail. So we check here. We expect
                    # this is rare.
                    
                    if ("${lock_proc}" == "") then
                        echo ${requesting_pid} >! ${lock_file}
                        ${WRN_ECHO} "Cannot read a process id from lock file. Assuming it needs to be removed."
                        set remove_lock_file = 1
                    else
                        ${VERBOSE_ECHO_2} "${VERBOSE_INDENT}Lock handler for ${requesting_pid} checking on lock file process ${lock_proc} on iteration ${count}." 
                        ps ${lock_proc} >& /dev/null
                        set ps_status = "${status}" 

                        if (${ps_status}) then
                            ${VERBOSE_ECHO} "${VERBOSE_INDENT}Lock handler for ${requesting_pid} reports process ${lock_proc} holding ${lock_file} no longer exists."
                            set remove_lock_file = 1
                        endif 
                    endif 


                    if (${remove_lock_file}) then
                        # OK it is stale, but danger, others might be trying to
                        # remove it too! So we do a mini lock for removing, but
                        # not by recursing into the ivi lock system! 

                        set rm_lock_file = "${lock_file}-RM-${lock_proc}"
                        
                        ${MAKE_SCRIPT_PATH}atomic_echo ${rm_lock_file} "${id}" 
                        set atomic_echo_status =  ${status}

                        if (${atomic_echo_status}) then
                            ${VERBOSE_ECHO} "${VERBOSE_INDENT}Lock handler for ${requesting_pid} failed to get lock for removing a lock. No action taken."
                        else 
                            ${VERBOSE_ECHO} "${VERBOSE_INDENT}Process ${requesting_pid} lock handler has got the lock file ${rm_lock_file} (contents `cat ${rm_lock_file}`)."
                            
                            # Check the file still exists and still has stale
                            # contents.

                            set really_remove_lock_file = 0

                            if (-e "${lock_file}") then
                                set new_lock_proc = `cat ${lock_file} | ${IVI_SED} 's/^.*-//'`

                                if (! ${status}) then
                                    # This covers both the case that the file is
                                    # still empty, and it contains a dead
                                    # process.

                                    if (${new_lock_proc} == ${lock_proc}) then
                                        set really_remove_lock_file = 1
                                    endif
                                endif 
                            endif 

                            if (${really_remove_lock_file}) then
                                ${IVI_RM} "${lock_file}"
                                ${VERBOSE_ECHO} "${VERBOSE_INDENT}Script ivi_lock_create removed lock file ${lock_file} as process ${lock_proc} does not exist."
                            else
                                ${VERBOSE_ECHO} "${VERBOSE_INDENT}Script ivi_lock_create not removing lock file ${lock_file} as it seems that someone else did it."
                            endif 

                            ${IVI_RM} "${rm_lock_file}"
                            ${VERBOSE_ECHO} "${VERBOSE_INDENT}Process ${requesting_pid} lock handler has relinquished the lock file ${rm_lock_file}."

                            continue
                        endif
                    else if (${time_waited} > ${max_time_to_wait}) then
                        ${P_STDERR} "Process $$ waited too long for ${lock_file} on behalf of process ${requesting_pid}. "
                        ${P_STDERR} "Process $$ waited for ${time_waited} X 0.01 seconds, exceeding the limit of ${max_time_to_wait} X 0.01 seconds."
                        set end_time = `date +%H:%M:%S`
                        ${P_STDERR} "Specifically it waited from ${start_time} to ${end_time}." 
                        ${P_STDERR} "Information about the process (${lock_proc}) holding the lock:"
                        ps -l ${lock_proc} 
                        ${P_STDERR} "Information about the process (${requesting_pid}) requesting the lock:"
                        ps -l ${requesting_pid} 

                        if ($?EXIT_ON_LOCK_TIMEOUT) then
                            ${P_STDERR} "Process $$ waiting for ${lock_file} exiting with failure because EXIT_ON_LOCK_TIMEOUT is set." 
                            set exit_status = 1
                            goto cleanup
                        endif 

                        ${P_STDERR} "Sleeping for 5 more seconds for debugging" 
                        sleep 5
                        ${P_STDERR} "Ignoring the lock."
                        echo ${requesting_pid} >! ${lock_file}
                        set got_it = 1
                        break
                    endif
                else
                    ${VERBOSE_ECHO_2} "${VERBOSE_INDENT}Lock handler for ${requesting_pid} not checking up on lock file process on iteration ${count}." 
                endif 

                ${VERBOSE_ECHO_2} "${VERBOSE_INDENT}Lock handler for ${requesting_pid} waiting for ${lock_file}."
                ${VERBOSE_ECHO_2} "${VERBOSE_INDENT}Lock handler for ${requesting_pid} sleeping for ${sleep_time} seconds"

                sleep ${sleep_time} >& /dev/null
                if (${status}) then
                    ${P_STDERR} "Fractional sleep failed in ivi_lock_create." 
                    set exit_status = 1
                    goto cleanup
                endif

                @ time_waited += ${w}
                ${VERBOSE_ECHO_2} "${VERBOSE_INDENT}Lock handler for ${requesting_pid} slept ${time_waited}/${max_time_to_wait} x 0.01 seconds."

                @ count ++
            end
        endif 

        if (${got_it}) break
    end

    ${VERBOSE_ECHO} "${VERBOSE_INDENT}Process $$ set lock with label ${lock_label} for process ${requesting_pid} in `pwd`."
    set end_time = `date +%H:%M:%S`
    ${VERBOSE_ECHO_2} "${VERBOSE_INDENT}Process $$ locking start time: ${start_time}."
    ${VERBOSE_ECHO_2} "${VERBOSE_INDENT}Process $$ locking   end time: ${end_time}."
endif 

cleanup: 
    
# Restore 
onintr
    
exit ${exit_status}

# We should not be here unless onintr

ivi_lock_create_bail:

${VERBOSE_ECHO} "${VERBOSE_INDENT}Process $$ doing ivi_lock_create got an interrupt."

# If we are not locking or even if we are, then the lock_file variable might not
# be set when we got interrupted.

if (${safe_to_lock}) then
    if (${?lock_file}) then 
        if (-e "${lock_file}") then 
            ${P_STDERR} "Script ivi_lock_create process $$ removing lock file ${lock_file} because of interrupt."
            ${P_STDERR} " "
            ${IVI_RM} "${lock_file}"
        endif 
    endif 
endif 

exit 1


   
