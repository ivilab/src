#!/bin/tcsh -f 

##############################################################################
#
# Identification:
#     Creates a semaphore that blocks cooperating processes from proceeding 
#     until removed (using ivi_lock_remove).
#
# Description:
#     This is a simple script for locking blocks of script code that is not
#     conveniently expressed as a command (otherwise use ivi_lock). It works
#     much like lockfile-create, and in fact, is implemented using
#     lockfile-create if it is available. The main justification for this script
#     is that locking is not universally available. Most notably good locking
#     facilities are not available in the mac OS. Hence, this script also
#     implements a fall back method that is less than ideal, but usually works. 
#
#     The argument to ivi_lock_create is simply a label (often just the name of the
#     script), which is combined with the current directory to create a lockfile
#     name. At the end of the protected code, you must call ivi_lock_remove
#     with exactly the same argument. 
#
#     If the environment variable IVI_LOCKING_METHOD is set, this script will
#     use its value for the locking method. Otherwise it will try
#     lockfile-progs, and then the built in fall back method. 
#
#     If the environment variable IVI_LOCKFILE_DIR is set, this script will use
#     its value as a directory to create lockfiles in. Otherwise, this script
#     will use ${TMPDIR}/${USER}/lockfiles/, creating it if needed.
#
#     if the environment variable IVI_LOCKFILE_NAME is set, then it overrides
#     the default heuristics for constructing the lock file name. If
#     IVI_LOCKFILE_NAME looks like a path it is used as is. Otherwise, we append
#     the string ".lock" to $IVI_LOCKFILE_NAME, and use that for a lockfile in
#     the lockfile directory.
#
#     Finally, if the environment variable IVI_DONT_LOCK is set, then this
#     script essentially does nothing. The main purpose of this is to avoid
#     deadlock when we effectively call scripts recursively. Normally there is a
#     better way to accomplish what you want to do.
#
# Deficiencies
#     The current implementation locks all runs of a command operating in a
#     given sub-directory, which is is not a big issue as it is simply overly
#     conservative. If this becomes an issue, we can put more path components in
#     the lockfile name. 
#
# Author:
#     Kobus Barnard 
#
##############################################################################

# We assume that init_scripts has been called as this script is largely used as
# part of the IVI build system reflected by the fact that it lives in Make.
# Thus, we have P_STDERR, VERBOSE_ECHO, and MAKE_SCRIPT_PATH. 

# This script must be kept in sync with ivi_lock_remove

# set echo

if ($# < 1) then
    ${P_STDERR} "Script ivi_lock_create needs at least one argument."
    exit 1
else if ($# < 2) then
    set requesting_pid = `ps -p $$ -o ppid=`
else 
    set requesting_pid = $2 
endif 

set lock_label = "$1"

set exit_status = 0

set noclober

if ($?LOCK_WAIT_TIME) then
    set lock_wait_time = $LOCK_WAIT_TIME
else 
    set lock_wait_time = 10
endif 

# The factor depends on how much we sleep. 2 is for expected value of .5
# seconds.
#
@ lock_wait_iterations = 2 * ${lock_wait_time}

if ($?IVI_DONT_LOCK) then
    ${VERBOSE_ECHO} "${VERBOSE_INDENT}IVI_DONT_LOCK is set, so ivi_lock_create is not doing anything"
    exit 0
endif

if (! $?IVI_LOCKING_METHOD) then
    # Sync this code with that in init_compile!

    if ((`${MAKE_SCRIPT_PATH}can_execute lockfile-create`) && (`${MAKE_SCRIPT_PATH}can_execute lockfile-remove`)) then
        setenv IVI_LOCKING_METHOD "lockfile-progs" 
    else
        setenv IVI_LOCKING_METHOD "fallback"
    endif 
endif 

if (! $?IVI_LOCKFILE_DIR) then
    setenv IVI_LOCKFILE_DIR ${TMPDIR}/${USER}/lockfiles/
endif 

${IVI_MKDIR} "${IVI_LOCKFILE_DIR}"

if ($status) then
    $P_STDERR "Unable to make directory ${IVI_LOCKFILE_DIR}"
    exit 1
endif 

set dir_str = `echo ${cwd} | sed 's#.*/##'`

if ($?IVI_LOCKFILE_NAME) then
    set looks_like_abs_path = `echo ${IVI_LOCKFILE_NAME} | grep -c '^/'`
    set looks_like_path = `echo ${IVI_LOCKFILE_NAME} | grep -c '/'`

    if (${looks_like_abs_path}) then
        set lock_file = "${IVI_LOCKFILE_NAME}"
    else if (${looks_like_path}) then
        set lock_file = "`pwd`/${IVI_LOCKFILE_NAME}"
    else 
        set lock_file = ${IVI_LOCKFILE_DIR}/${IVI_LOCKFILE_NAME}.lock
    endif 
else
    set lock_file = ${IVI_LOCKFILE_DIR}/${lock_label}_${dir_str}.lock
endif 

# Mostly for testing and debugging.
setenv IVI_LOCKFILE_PATH "${lock_file}"

onintr bail

${VERBOSE_ECHO} "${VERBOSE_INDENT}Script ivi_lock_create process $$ running lock_create ${lock_label} for ${requesting_pid}."
${VERBOSE_ECHO} "${VERBOSE_INDENT}    in `pwd` using lockfile '${lock_file}'"

if ("${IVI_LOCKING_METHOD}" == "lockfile-progs") then
    ${VERBOSE_ECHO} "${VERBOSE_INDENT}Process $$ running lock_create ${lock_label} in `pwd` using lockfile-progs"
    lockfile-create ${lock_file}

    if (! ${status}) then
        ${VERBOSE_ECHO} "${VERBOSE_INDENT}Process $$ successfully set ${lock_label} in `pwd` using lockfile-create."
    endif
else 
    # Fallback locking method. Doing locking robustly in scripts is hard, but
    # often (e.g., mac) we do not have a good solution. The following is better
    # than nothing.

     ${VERBOSE_ECHO}  "${VERBOSE_INDENT}Process $$ running lock_create ${lock_label} in `pwd` using fallback locking system."

    # Reduce the chances of everyone wanting to start at the same time.
    # I do not know how likely this is to fail, or even to return success
    # without doing the right thing, but it seems to work on the mac. 

    set x = ${requesting_pid} ; @ x %= 100 ; set sleep_time = "0.${x}"

    ${VERBOSE_ECHO} echo "${VERBOSE_INDENT}Process $$ sleeping for ${sleep_time} seconds"

    sleep ${sleep_time}

    if (${status}) then
        ${P_STDERR} "Fractional sleep failed in ivi_lock_create." 
        set exit_status = 1
        goto cleanup
    endif

    while (1) 
        if (! -e "${lock_file}") then
            # Unlike some of the similar lines below, we do not have an '!'
            # after the '>', as we want to fail due to noclober.
            #
            echo ${requesting_pid} > ${lock_file}

            # Someone else might have just written the file. 
            if (${status}) then
                #  I have not found a safe way to ignore error output. 
                set apparent_lock_owner = `cat ${lock_file}`
                if (${status}) then
                    echo "Someone might have snuck in before me (${requesting_pid}). Sleeping."
                else
                    echo "Requesting process ${apparent_lock_owner} snuck in before me (${requesting_pid}). Sleeping."
                endif 

                set x = ${requesting_pid} ; @ x %= 100 ; set sleep_time = "0.${x}"

                ${VERBOSE_ECHO} "${VERBOSE_INDENT}Process $$ sleeping for ${sleep_time} seconds for ${requesting_pid}."

                sleep ${sleep_time}

                if (${status}) then
                    ${P_STDERR} "Fractional sleep failed in ivi_lock_create." 
                    set exit_status = 1
                    goto cleanup
                endif

                continue
            endif 

            ${VERBOSE_ECHO} echo "${VERBOSE_INDENT}Process $$ tentatively set lock file ${lock_file} for ${requesting_pid}."
            # ps -l $$
        else 
            set count = 0
            set got_it = 0

            while (-e "${lock_file}")
                #  I have not found a safe way to ignore error output. 
                set lock_proc = `cat ${lock_file}`

                # Happens! 
                if ($status) then 
                    echo ${requesting_pid} >! ${lock_file}
                    echo "Lock file ${lock_file} disappeared! Taking the lock."
                    set got_it = 1
                    break
                endif 

                # If the contents is bogus, then the ps below will fail. But if
                # it is empty, ps will not fail. So we check here. 
                #
                if ("${lock_proc}" == "") then
                    echo ${requesting_pid} >! ${lock_file}
                    echo "Cannot read a process id from lock file. Assuming it is stale."
                    set got_it = 1
                    break
                endif 

                ${VERBOSE_ECHO_2} "${VERBOSE_INDENT}Lock file ${lock_file} exists."
                ${VERBOSE_ECHO_2} "${VERBOSE_INDENT}Checking on lock file process ${lock_proc}." 

                ps ${lock_proc} >& /dev/null
                set ps_status = "${status}" 

                if (${ps_status}) then
                    echo ${requesting_pid} >! ${lock_file}

                    ${VERBOSE_ECHO} "${VERBOSE_INDENT}Process $$ resetting lock file ${lock_file} for process ${requesting_pid} as process ${lock_proc} does not exist."

                    set got_it = 1
                    break
                else if (${count} > ${lock_wait_iterations}) then
                    echo "Process $$ waited too long for ${lock_file}. "
                    echo "It waited ${lock_wait_iterations} iterations which is about ${lock_wait_time}s. "
                    echo "Information about the process holding the lock:"
                    ps -l ${lock_proc} 
                    echo "Sleeping for 10 seconds for debugging" 
                    sleep 10
                    echo "Ignoring the lock."
                    echo ${requesting_pid} >! ${lock_file}
                    set got_it = 1
                    break
                else  
                    ${VERBOSE_ECHO} "${VERBOSE_INDENT}Process $$ waiting for ${lock_file} held by process ${lock_proc} on behalf of process ${requesting_pid} ."

                    # Add some fractional seconds to reduce the chances of everyone
                    # wanting to start at the same time.
                    set x = ${requesting_pid} ; @ x %= 100 ; set sleep_time = "0.${x}"

                    ${VERBOSE_ECHO} "${VERBOSE_INDENT}Process $$ sleeping for ${sleep_time}"

                    sleep ${sleep_time} >& /dev/null
                    # set x = $$ ; @ x %= 100 ; sleep 1.$x >& /dev/null

                    if (${status}) then
                        ${P_STDERR} "Fractional sleep failed in ivi_lock_create." 
                        set exit_status = 1
                        goto cleanup
                    
                    endif

                    @ count ++
                endif
            end

            # If we got_it is still false, then the lock file was removed by the
            # process we were waiting on.
            #
            if (! ${got_it}) then
                echo ${requesting_pid} >! ${lock_file}
                ${VERBOSE_ECHO} "${VERBOSE_INDENT}Process $$ setting lock file ${lock_file} for process ${lock_proc} as the lock file no longer exists."
            endif 
        endif 

        # Check for clash. I have not found a safe way to ignore error output. 
        set lock_proc = `cat ${lock_file}` 
        if (${status}) then
            # Could happen.
            ${VERBOSE_ECHO} "${VERBOSE_INDENT}Lock file ${lock_file} disappeared. Trying again to get the lock."
        else if (${lock_proc} != ${requesting_pid}) then 
            ${VERBOSE_ECHO} "${VERBOSE_INDENT}Process ${lock_proc} beat us to the lock on ${lock_file}. Resuming waiting."
        else 
            break
        endif 
    end

    ${VERBOSE_ECHO} "${VERBOSE_INDENT}Process $$ successfully set ${lock_label} on behalf of process ${requesting_pid} in `pwd` using fallback locking method."
endif 

cleanup: 
    
exit ${exit_status}

# We should not be here unless onintr

bail:

if (-e "${lock_file}") then 
    echo "Script ivi_lock_create process $$ removing lock file ${lock_file} because of interrupt."
    echo " "
    ${IVI_RM} "${lock_file}"
endif 

exit 1


   
