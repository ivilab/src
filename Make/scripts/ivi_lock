#!/bin/tcsh -f 

##############################################################################
#
# Identification:
#     A script to execute commands so that only one instance is run at a time. 
#
# Description:
#     This is a simple script for locking. It trades limited capability for
#     simplicity (see deficiencies below). Using it is a lot like using "flock",
#     and in fact, it is implemented using flock if flock is available. The
#     main justification for this script is that locking is not universally
#     available. Most notably good locking facilities are not available in the
#     mac OS. Hence, this script implements a fall back method that is less than
#     ideal, but usually works. 
#
#     The first argument to ivi_lock is the max number of seconds to wait. This
#     has to be first because the command can have an arbitrary number of
#     arguments.
#
#     The second argument to ivi_lock is the command to be executed including its
#     arguments. This script supports two forms of simple locking. One is based
#     on the command, and the other is based on a resource labeled by the value
#     of the environment variable IVI_LOCKFILE_NAME. 
#
#     For command based locking (simplest), this script constructs a lock name
#     based on the command and a piece of the current directory.  This makes
#     sense if the command is the only way that particular files get modified
#     and/or might do a sequence of steps that all need to be protected, and/or
#     actions needing protection are not described as modifying an obvious
#     resource (e.g., updating an SVN repo).
#
#     However, command based locking does not support multiple scripts that
#     share a resource that needs to be protected. For this scenario, the set of
#     scripts can set a specific named lock via the environment variable
#     IVI_LOCKFILE_NAME. Usually this is an informative string (no slashes
#     are allowed). However, if IVI_LOCKFILE_NAME holds a path, then that path
#     is taken as the precise lockfile, and the behaviour is similar to "flock",
#     especially if flock is the underlying implementation.
#
#     If the environment variable IVI_FLOCK_METHOD is set, this script will
#     use its value for the locking method. Current settings include "flock",
#     and "ivi". If "ivi" then the locking is further modifiable (on systems
#     where there is a choice) via IVI_LOCK_PROGS_METHOD. 
#
#     If the environment variable IVI_LOCKFILE_PATH is set, this script will use
#     its value as a directory to create lockfiles in. Otherwise, this script
#     will use ${TMPDIR}/${USER}/lockfiles/, creating it if needed.
#
#     Finally, if the environment variable IVI_DONT_LOCK is set, then this
#     script runs the argument without any locking. The main purpose of this is
#     to avoid deadlock when we effectively call scripts recursively. Normally
#     there is a better way to accomplish what you want to do, but one instance
#     where such a way is yet to be discovered is in repository synchronization
#     where we want 'to' and 'from' processes to share locks, but also call each
#     other.
#
# Deficiencies
#     The current implementation locks all runs of a command operating in a
#     given sub-directory, irrespective of arguments or parent directory, which
#     is is not a big issue as it is simply overly conservative. If this becomes
#     an issue, we can put more path components in the lockfile name. 
#
#     If IVI_LOCKFILE_NAME looks like a path, we do not add ".lock" to the name,
#     but if it is a simple string without '/', then we do add '.lock'. This
#     behavior might confuse some (and is easy to change), but the reasoning is
#     that one should be able to have full control if needed, by specifying the
#     full path, and we arbitrarily keep that same behavior for relative paths,
#     as the path is now relative to where you are running things, not the
#     IVI_LOCKFILE_PATH (which might also confuse). This scenario seems
#     unlikely.
#
# Author:
#     Kobus Barnard 
#
##############################################################################

# We assume that init_scripts has been called as this script is largely used as
# part of the IVI build system reflected by the fact that it lives in Make.
# Thus, we have P_STDERR, VERBOSE_ECHO, and MAKE_SCRIPT_PATH. 

if ($?IVI_SET_ECHO) then
    set echo
endif 

if ($# < 2) then
    ${P_STDERR} "Script ivi_lock needs at least two arguments."
    exit 1
endif 

# Don't really need to error check as ivi_lock_create does it, but this might
# help get to the source faster.
#
set max_time_to_wait = "$1"

if ("${max_time_to_wait}" == "") then
    ${P_STDERR} "Script ivi_lock received a null first argument."
    exit 1 
endif 

set check_time_arg = `echo "${max_time_to_wait}" | sed 's/[0-9]//g'`
if ("${check_time_arg}" != "") then
    ${P_STDERR} "Script ivi_lock first arg (${max_time_to_wait} must be a non-negative integer."
    exit 1 
endif 

set full_cmd = "$argv[2-$#]"
set cmd_str = `echo ${2} | sed 's#.*/##'`
set lock_label = "${cmd_str}"

if ($# > 2) then
    if ("${3}" == "") then
        set first_arg = "NULL"
    else 
        set first_arg = `echo ${3} | sed 's#//*$##' | sed 's#.*/##' `

        if ("${first_arg}" == "") then
            ${P_STDERR} "Script ivi_lock unable to make non-empty string out of command arg: |$3|"
            exit 1
        endif 
    endif 
    
    set lock_label = "${lock_label}_${first_arg}"
endif 

# Last path component.
set dir_str = `echo ${cwd} | sed 's#.*/##'`
set lock_label = "${lock_label}_${dir_str}"

${VERBOSE_ECHO} "${VERBOSE_INDENT}Script ivi_lock process $$ called with args:"
${VERBOSE_ECHO} "${VERBOSE_INDENT}    $*"
${VERBOSE_ECHO} "${VERBOSE_INDENT}    in `pwd` "

if ($?IVI_DONT_LOCK) then
    ${VERBOSE_ECHO} "${VERBOSE_INDENT}IVI_DONT_LOCK is set, so ivi_lock is not locking: $*"
    ${full_cmd} 
    exit ${status}
endif

set exit_status = 0

onintr ivi_lock_bail

# This bit of shared code sets "safe_to_lock" and requires "lock_label".
source ${MAKE_SCRIPT_PATH}check_for_deadlock
if (${status}) exit ${status} 

if  ("${IVI_FLOCK_METHOD}" == "flock") then
    ${VERBOSE_ECHO} "${VERBOSE_INDENT}Process $$ running ${cmd_str} in `pwd` using 'flock'"

    source ${MAKE_SCRIPT_PATH}set_lockfile_name
    if (${status}) exit ${status} 

    if (${safe_to_lock}) then
        flock -E 22 -w ${max_time_to_wait} ${lock_file} ${full_cmd}
        set flock_status = ${status}
        if (${flock_status}) then
            ${P_STDERR} "Command failed in ivi_lock in ${cwd}: flock -w ${max_time_to_wait} ${lock_file} ${full_cmd}"
            if (${flock_status} == 22) then
                ${P_STDERR} "Flock failure likley due to time out which was set to ${max_time_to_wait}."
            endif 

            set exit_status = 1
        endif 
    else
        ${full_cmd}
        if (${status}) then
            ${P_STDERR} "Command failed in ivi_lock in ${cwd}: ${full_cmd}"
            set exit_status = 1
        endif 
    endif 

    if (! ${exit_status}) then
        ${VERBOSE_ECHO} "${VERBOSE_INDENT}Process $$ successfully ran ${cmd_str} in `pwd` using 'flock'"
    endif
else 
    # IVI locking method. Doing locking robustly in scripts is hard, but
    # often (e.g., mac) we do not have a good solution. The following is better
    # than nothing.

    ${VERBOSE_ECHO} "${VERBOSE_INDENT}Process $$ running ${cmd_str} in `pwd` using IVI locking system."

    set requesting_pid = `ps -p $$ -o ppid=`

    if (${safe_to_lock}) then
        ${MAKE_SCRIPT_PATH}ivi_lock_create ${max_time_to_wait} ${lock_label} ${requesting_pid}
        if ($status) then 
            ${VERBOSE_ECHO} "${VERBOSE_INDENT}Call to ivi_lock_create from ivi_lock failed."
            set exit_status = 1
        endif 
    else 
        ${VERBOSE_ECHO} "${VERBOSE_INDENT}Script ivi_lock skipping call to ivi_lock_create as it is not safe to lock."
    endif  

    if (! ${exit_status}) then
        ${VERBOSE_ECHO}  "${VERBOSE_INDENT}Process $$ executing ${full_cmd}"
        ${full_cmd} 
        set exit_status = $status 
        ${VERBOSE_ECHO}  "${VERBOSE_INDENT}Executing ${full_cmd} had exit status ${exit_status}."
    endif 

    if (${safe_to_lock}) then
        ${MAKE_SCRIPT_PATH}ivi_lock_remove ${lock_label} ${requesting_pid}
    else 
        ${VERBOSE_ECHO} "${VERBOSE_INDENT}Script ivi_lock skipping call to ivi_lock_remove as it is not safe to lock."
    endif  

    if (! ${exit_status}) then 
        ${VERBOSE_ECHO}  "${VERBOSE_INDENT}Process $$ successfully ran ${cmd_str} in `pwd` using IVI locking method."
    endif 
        
    ${VERBOSE_ECHO} "${VERBOSE_INDENT}Process $$ finishing up up ivi_lock with IVI locking method."
endif 

cleanup: 

# Restore 
onintr
    
exit ${exit_status}

# We should not be here unless onintr

ivi_lock_bail:

${VERBOSE_ECHO} "${VERBOSE_INDENT}Process $$ doing ivi_lock got an interrupt."

# If we are not locking or even if we are, then the lock_file variable might not
# be set when we got interrupted.

if (${safe_to_lock}) then
    if (${?lock_file}) then 
        if (-e "${lock_file}") then 
            ${P_STDERR} "Script ivi_lock process $$ removing lock file ${lock_file} because of interrupt."
            ${P_STDERR} " "
            ${IVI_RM} "${lock_file}"
        endif 
    endif 
endif 

exit 1


   
