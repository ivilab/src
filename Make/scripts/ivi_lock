#!/bin/tcsh -f 

##############################################################################
#
# Identification:
#     A script to execute commands so that only one instance is run at a time. 
#
# Description:
#     This is a simple script for locking. It trades limited capability for
#     simplicity (see deficiencies below). Using it is a lot like using "flock",
#     and in fact, it is implemented using flock if flock is available. The
#     main justification for this script is that locking is not universally
#     available. Most notably good locking facilities are not available in the
#     mac OS. Hence, this script implements a fall back method that is less than
#     ideal, but usually works. 
#
#     The argument to ivi_lock is the command to be executed including its
#     arguments. This script supports two forms of simple locking. One is based
#     on the command, and the other is based on a resource labeled by the value
#     of the environment variable IVI_LOCKFILE_NAME. 
#
#     For command based locking (simplest), this script constructs a lock name
#     based on the command and a piece of the current directory.  This makes
#     sense if the command is the only way that particular files get modified
#     and/or might do a sequence of steps that all need to be protected, and/or
#     actions needing protection are not described as modifying an obvious
#     resource (e.g., updating an SVN repo).
#
#     However, command based locking does not support multiple scripts that
#     share a resource that needs to be protected. For this scenario, the set of
#     scripts can set a specific named lock via the environment variable
#     IVI_LOCKFILE_NAME. Usually this is an informative string (no slashes
#     are allowed). However, if IVI_LOCKFILE_NAME holds a path, then that path
#     is taken as the precise lockfile, and the behaviour is similar to "flock",
#     especially if flock is the underlying implementation.
#
#     If the environment variable IVI_LOCKING_METHOD is set, this script will
#     use its value for the locking method. Otherwise it will try flock, then
#     lockfile-progs, and then the built in fall back method. 
#
#     If the environment variable IVI_LOCKFILE_DIR is set, this script will use
#     its value as a directory to create lockfiles in. Otherwise, this script
#     will use ${TMPDIR}/${USER}/lockfiles/, creating it if needed.
#
#     Finally, if the environment variable IVI_DONT_LOCK is set, then this
#     script runs the argument without any locking. The main purpose of this is
#     to avoid deadlock when we effectively call scripts recursively. Normally
#     there is a better way to accomplish what you want to do, but one instance
#     where such a way is yet to be discovered is in repository synch'ing where
#     we want 'to' and 'from' processes to share locks, but also call each
#     other.
#
# Deficiencies
#     The current implementation locks all runs of a command operating in a
#     given sub-directory, irrespective of arguments or parent directory, which
#     is is not a big issue as it is simply overly conservative. If this becomes
#     an issue, we can put more path components in the lockfile name. 
#
#     If IVI_LOCKFILE_NAME looks like a path, we do not add ".lock" to the name,
#     but if it is a simple string without '/', then we do add '.lock'. This
#     behavior might confuse some (and is easy to change), but the reasoning is
#     that one should be able to have full control if needed, by specifying the
#     full path, and we arbitrarily keep that same behavior for relative paths,
#     as the path is now relative to where you are running things, not the
#     IVI_LOCKFILE_DIR (which might also confuse). This scenario seems unlikely.
#
# Author:
#     Kobus Barnard 
#
##############################################################################

if ($?IVI_SET_ECHO) then
    set echo
endif 

if ($# < 1) then
    ${P_STDERR} "Script ivi_lock needs at least one argument."
    exit 1
endif 

set exit_status = 0

if ($?IVI_VERBOSE) then
    if ($?IVI_VERBOSE_INDENT) then
        set verbose_indent = "${IVI_VERBOSE_INDENT}"
    else
        set verbose_indent = ""
    endif
endif 

if ($?IVI_DONT_LOCK) then
    ${VERBOSE_ECHO} "${verbose_indent}IVI_DONT_LOCK is set, so ivi_lock is not locking: $*"
    $*
    exit ${status}
endif

if (! $?IVI_LOCKING_METHOD) then
    # Sync this code with that in init_compile (or init_scripts as it might
    # move)!

    if (`${MAKE_SCRIPT_PATH}can_execute flock`) then
        setenv IVI_LOCKING_METHOD "flock" 
    else if ((`${MAKE_SCRIPT_PATH}can_execute lockfile-create`) && (`${MAKE_SCRIPT_PATH}can_execute lockfile-remove`)) then
        setenv IVI_LOCKING_METHOD "lockfile-progs" 
    else
        setenv IVI_LOCKING_METHOD "fallback"
    endif 
endif 

# Even if we are given a lockfile , we still need to have a directory to put the
# lock timestamp file. 
#
if (! $?IVI_LOCKFILE_DIR) then
    setenv IVI_LOCKFILE_DIR ${TMPDIR}/${USER}/lockfiles/
endif 

${IVI_MKDIR} "${IVI_LOCKFILE_DIR}"

if ($status) then
    $P_STDERR "Unable to make directory ${IVI_LOCKFILE_DIR}"
    exit 1
endif 

set dir_str = `echo ${cwd} | sed 's#.*/##'`
set cmd_str = `echo ${1} | sed 's#.*/##'`

if ($# > 1) then
    set first_arg = `echo ${2} | sed 's#//*$##' | sed 's#.*/##' `
    set cmd_plus_arg = "${cmd_str}_${first_arg}"
else 
    set cmd_plus_arg = "${cmd_str}"
endif 

if ($?IVI_LOCKFILE_NAME) then
    set looks_like_abs_path = `echo ${IVI_LOCKFILE_NAME} | grep -c '^/'`
    set looks_like_path = `echo ${IVI_LOCKFILE_NAME} | grep -c '/'`

    if (${looks_like_abs_path}) then
        set lock_file = "${IVI_LOCKFILE_NAME}"
    else if (${looks_like_path}) then
        set lock_file = "`pwd`/${IVI_LOCKFILE_NAME}"
    else 
        set lock_file = ${IVI_LOCKFILE_DIR}/${IVI_LOCKFILE_NAME}.lock
    endif 
else
    set lock_file = ${IVI_LOCKFILE_DIR}/${cmd_plus_arg}_${dir_str}.lock
endif 

# Mostly for testing and debugging.
setenv IVI_LOCKFILE_PATH "${lock_file}"

onintr bail

# Best not to use VERBOSE_PSO in this script due to '-f'.
if ($?IVI_VERBOSE) then
    echo "${verbose_indent}Script ivi_lock process $$ running $*"
    echo "${verbose_indent}    in `pwd` using lockfile '${lock_file}'"
endif

if  ("${IVI_LOCKING_METHOD}" == "flock") then
    # Best not to use VERBOSE_PSO here.
    if ($?IVI_VERBOSE) then
        echo "${verbose_indent}Process $$ running ${cmd_str} in `pwd` using 'flock'"
    endif

    flock ${lock_file} $*
    set exit_status = ${status}

    if (! ${exit_status}) then
        # Best not to use VERBOSE_PSO here.
        if ($?IVI_VERBOSE) then
            echo "${verbose_indent}Process $$ successfully ran ${cmd_str} in `pwd` using 'flock'"
        endif
    endif
else if ("${IVI_LOCKING_METHOD}" == "lockfile-progs") then
    # if ($?IVI_VERBOSE) then
        echo "Process $$ running ${cmd_str} in `pwd` using lockfile-progs"
    # endif 
#     echo "Exiting with error as this is unfinished."
#     exit 1

    lockfile-create ${cmd_str}
    $*
    set exit_status = $status 
    lockfile-remove ${cmd_str}

    if (! ${exit_status}) then 
        # Best not to use VERBOSE_PSO here.
        if ($?IVI_VERBOSE) then
            echo "${verbose_indent}Process $$ successfully ran ${cmd_str} in `pwd` using lockfile-progs locking method."
        endif
    endif 
else 
    # Fallback locking method. Doing locking robustly in scripts is hard, but
    # often (e.g., mac) we do not have a good solution. The following is better
    # than nothing.
    

    # Best not to use VERBOSE_PSO here.
    if ($?IVI_VERBOSE) then
        echo "${verbose_indent}Process $$ running ${cmd_str} in `pwd` using fallback locking system."
    endif

    set requesting_pid = `ps -p $$ -o ppid=`
    ${MAKE_SCRIPT_PATH}ivi_lock_create ${cmd_str} ${requesting_pid}
    $*
    set exit_status = $status 
    ${MAKE_SCRIPT_PATH}ivi_lock_remove ${cmd_str} ${requesting_pid}

    if (! ${exit_status}) then 
        # Best not to use VERBOSE_PSO here.
        if ($?IVI_VERBOSE) then
            echo "${verbose_indent}Process $$ successfully ran ${cmd_str} in `pwd` using fallback locking method."
        endif
    endif 
        
    # Best not to use VERBOSE_PSO here.
    if ($?IVI_VERBOSE) then
        echo "${verbose_indent}Process $$ successfully ran ${cmd_str} in `pwd` using fallback locking method."
    endif
endif 

cleanup: 
    
exit ${exit_status}

# We should not be here unless onintr

bail:

if (-e "${lock_file}") then 
    ${P_STDERR} "Script ivi_lock process $$ removing lock file ${lock_file} because of interrupt."
    ${P_STDERR} " "
    ${IVI_RM} "${lock_file}"
endif 

exit 1


   
