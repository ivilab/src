#!/bin/tcsh -f

##################################################################################
#
#
${VERBOSE_ECHO} "${VERBOSE_INDENT}Entering script build_sub_libs_needed_parallel in ${cwd}."

set current_sub_lib = `echo ${cwd} | sed 's#.*/lib/\([^/]*\)$#\1#'`

if ("${current_sub_lib}" == "${cwd}") then
    set current_sub_lib = ""
endif 

if ((-d ${IVI_LIB_PATH}) && (-r ${IVI_LIB_PATH}) && (-x ${IVI_LIB_PATH})) then
    pushd ${IVI_LIB_PATH} > /dev/null
    # Insure no trailing slash.
    set real_ivi_lib_dir = `echo ${cwd} | sed 's/\/*$//'`
    # Add a trailing slash. 
    set real_ivi_lib_dir = "${real_ivi_lib_dir}/"
    popd > /dev/null
else
    set real_ivi_lib_dir = ""
endif 

# echo build_sub_libs_needed: real_ivi_lib_dir: ${real_ivi_lib_dir} 

set sub_libs_needed = ""

set recurse_dir_strs = ""

foreach recurse_dir ($*)
    set test_places = "${real_ivi_lib_dir} lib/ ../lib/ ../../lib/ ../../../lib/ ../../../../lib/ ../../../../../lib/"

    set recurse_dir_str = ""

    foreach test_place (${test_places}) 
        if (-d "${test_place}${recurse_dir}") then
            # Retrospective summer 2020. Can we hope that the need for this is
            # long gone? It is not clear what is wrong with links anyway.
            # Perhaps someone wants to hack it this way?
            #
            # Expensive, but need to test for links due to legacy code. 
            # We could copy the code for "is_link" to speed things up a bit.
            # set is_link = `${MAKE_SCRIPT_PATH}is_link ${test_place}${recurse_dir}`

            # if (! ${is_link} ) then
               set recurse_dir_str = "${test_place}${recurse_dir}"
               break
            # endif 
        endif 
    end 

    if ("${recurse_dir_str}" == "") then
        ${VERBOSE_ECHO} "${VERBOSE_INDENT}Script build_sub_libs_needed skipping ${recurse_dir} because it does not exist."
        continue
    endif 

    pushd ${recurse_dir_str} > /dev/null
        set recurse_dir_path = "${cwd}"
    popd  > /dev/null

    if ("${cwd}" == "${recurse_dir_path}") then 
        continue
    endif 

    set recurse_dir_strs = "${recurse_dir_strs} ${recurse_dir_str}"
end 

@ num_procs = 0

foreach recurse_dir_str (${recurse_dir_strs})
    ${VERBOSE_ECHO_2} " "
    ${VERBOSE_ECHO_2} "${VERBOSE_INDENT}------- Script build_sub_libs_needed considering ${recurse_dir_str} ----------"
    ${VERBOSE_ECHO_2} " "

    pushd ${recurse_dir_str} > /dev/null
        ${IVI_RM} SUB_LIB_BUILD_FAILED

        # File_list should be OK, so this is a little bit of overkill. Also,
        # note that we are going for the ".new" versions ofinclude_lines for
        # further robustness at the expense of speed. 
        
        ${MAKE_SCRIPT_PATH}ivi_lock_for_make 30 Include_lines/file_list ${MAKE_SCRIPT_PATH}build_file_list_2
        if (${status}) exit ${status}

        if (! -e "Include_lines/sub_libs_needed") then
            ${VERBOSE_ECHO_2} "${VERBOSE_INDENT}------- ${cwd}/Include_lines/sub_libs_needed does not exit ----------"
            set sub_libs_too_old = 1
        else 
            set sub_libs_too_old = `${MAKE_SCRIPT_PATH}test_older_than Include_lines/sub_libs_needed Include_lines/include_lines.new`
        endif 

        if (${sub_libs_too_old}) then
            ${VERBOSE_ECHO_2} "${VERBOSE_INDENT}------- ${cwd}/Include_lines/sub_libs_needed is too old ----------"
            ${VERBOSE_ECHO} " "
            ${VERBOSE_ECHO} "${VERBOSE_INDENT}------- Script build_sub_libs_needed recursing into ${recurse_dir_str} ----------"
            ${VERBOSE_ECHO} " "

            # This is the recursive call, as build_include_lines_2 calls
            # build_sub_libs_needed.
            #
            ${MAKE_SCRIPT_PATH}ivi_lock_for_make 30 Include_lines/sub_libs_needed ${MAKE_SCRIPT_PATH}build_include_lines_2 &
            @ num_procs ++
        else 
            ${VERBOSE_ECHO} " "
            ${VERBOSE_ECHO} "${VERBOSE_INDENT}------- Directory ${recurse_dir_str} already visited recently (no recursion needed) ----------"
            ${VERBOSE_ECHO} " "
        endif 
    popd  > /dev/null
end

${VERBOSE_ECHO} "${VERBOSE_INDENT}------- Number of processes to wait for in build_sub_libs_needed_parallel is ${num_procs}."

if (${num_procs} > 0) then
    wait 
endif 

set exit_status = 0

foreach recurse_dir_str (${recurse_dir_strs})
    pushd ${recurse_dir_str} > /dev/null
       if (-e SUB_LIB_BUILD_FAILED) then
           set exit_status = 1
           ${P_STDERR} "Parallel build of sub_libs_needed in ${cwd} FAILED."
       endif 
    popd  > /dev/null
end 

if ($exit_status) goto end_of_script

foreach recurse_dir_str (${recurse_dir_strs})
    pushd ${recurse_dir_str} > /dev/null
        if (-e ${recurse_dir_str}/Include_lines/sub_libs_needed) then
            set inherited_sub_libs = `${IVI_CAT} ${recurse_dir_str}/Include_lines/sub_libs_needed`
        else 
            set inherited_sub_libs = ""
            # Seems like an error.
            ${P_STDERR} "Warning: Script build_sub_libs_needed expected ${recurse_dir_str}/Include_lines/sub_libs_needed to exist by now."
            set exit_status = 1
            goto end_of_script
        endif 

        # If we just built ${recurse_dir}/Include_lines/sub_libs_needed, then we
        # should have spotted the problem, but if, for some reason we got fooled
        # into believing that file to be correct when it is not (legacy?), then we
        # need to check. It does not seem likely that we would not have caught it by
        # now though, hence the warning.
        #
        foreach inherited_sub_lib (${inherited_sub_libs})
            if ("${inherited_sub_lib}" == "${current_sub_lib}") then
                ${P_STDERR} " "
                ${P_STDERR} "Circular include spotted while building Include_lines/sub_libs_needed in ${cwd}."
                ${P_STDERR} "We have read these dirs from ${recurse_dir_str}/Include_lines/sub_libs_needed: ${inherited_sub_libs}"
                ${P_STDERR} "Directory ${current_sub_lib} needs ${recurse_dir}."
                ${P_STDERR} "But directory ${recurse_dir} needs ${current_sub_lib}."
                ${P_STDERR} " "

                if (-e Include_lines) then
                    ${P_STDERR} "Removing ${cwd}/Include_lines due to failure of build_include_lines_2."
                    find Include_lines -delete
                endif 

                ${P_STDERR} " "

                exit 1
            endif 
        end

        foreach test_item (${inherited_sub_libs} ${recurse_dir}) 
            set found = 0

            foreach item (${sub_libs_needed}) 
                if ("${item}" == "${test_item}") then
                    set found = 1
                    break
                endif 
            end

            if (${found}) continue

            set sub_libs_needed = "${sub_libs_needed} ${test_item}"
       end 
   popd  > /dev/null
   
   ${VERBOSE_ECHO_2} "${VERBOSE_INDENT}After recurse dir ${recurse_dir} inferred sub_libs_needed by ${cwd} are: ${sub_libs_needed}" 
end 

${VERBOSE_ECHO} "${VERBOSE_INDENT}After recursion inferred sub_libs_needed by ${cwd} are: ${sub_libs_needed}" 

${VERBOSE_ECHO} "${VERBOSE_INDENT}Writing ${cwd}/Include_lines/sub_libs_needed"
echo "${sub_libs_needed}" > Include_lines/sub_libs_needed 

end_of_script: 

${VERBOSE_ECHO} "${VERBOSE_INDENT}Leaving script build_sub_libs_needed_parallel with status ${exit_status} in ${cwd}."

